{"version":3,"file":"static/js/chunk-mix3.8d130e37.chunk.js","mappings":"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","sources":["../node_modules/.pnpm/registry.npmmirror.com+@remix-run+router@1.16.1/node_modules/@remix-run/router/history.ts","../node_modules/.pnpm/registry.npmmirror.com+@remix-run+router@1.16.1/node_modules/@remix-run/router/utils.ts","../node_modules/.pnpm/registry.npmmirror.com+@remix-run+router@1.16.1/node_modules/@remix-run/router/router.ts","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useMediaQuery.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useBreakpoint.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useCallbackRef.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useCommittedRef.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useEventCallback.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useEventListener.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useForceUpdate.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useIsomorphicEffect.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useMergedRefs.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useMounted.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/usePrevious.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useTimeout.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useWillUnmount.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useUpdatedRef.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useResizeObserver.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/Anchor.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/Button.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/DataKey.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/Dropdown.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/DropdownContext.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/DropdownItem.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/DropdownMenu.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/DropdownToggle.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/useRTGTransitionProps.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/RTGTransition.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/ImperativeTransition.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/Modal.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/ModalManager.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/getScrollbarWidth.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/Nav.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/NavContext.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/NavItem.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/NoopTransition.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/useRootClose.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/Overlay.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/SelectableContext.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/TabContext.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/TabPanel.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/Tabs.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/mergeOptionsWithPopperConfig.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/useClickOutside.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+hooks@0.4.16_react@18.3.1/node_modules/@restart/hooks/esm/useSafeState.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/popper.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/usePopper.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/useWaitForDOMRef.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/useWindow.js","../node_modules/.pnpm/registry.npmmirror.com+@restart+ui@1.6.9_react-dom@18.3.1_react@18.3.1/node_modules/@restart/ui/esm/utils.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/index.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/adapters/xhr.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/axios.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/cancel/CancelToken.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/cancel/CanceledError.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/cancel/isCancel.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/core/Axios.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/core/AxiosError.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/core/InterceptorManager.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/core/buildFullPath.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/core/dispatchRequest.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/core/mergeConfig.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/core/settle.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/core/transformData.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/defaults/index.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/defaults/transitional.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/env/classes/FormData.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/env/data.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/AxiosURLSearchParams.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/bind.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/buildURL.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/combineURLs.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/cookies.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/formDataToJSON.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/isAbsoluteURL.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/isAxiosError.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/isURLSameOrigin.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/normalizeHeaderName.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/parseHeaders.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/parseProtocol.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/spread.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/toFormData.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/toURLEncodedForm.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/helpers/validator.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/platform/browser/classes/FormData.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/platform/browser/index.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/platform/index.js","../node_modules/.pnpm/registry.npmmirror.com+axios@0.28.1/node_modules/axios/lib/utils.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/convert/dmp.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/convert/xml.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/diff/array.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/diff/base.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/diff/character.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/diff/css.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/diff/json.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/diff/line.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/diff/sentence.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/diff/word.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/index.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/patch/apply.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/patch/create.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/patch/merge.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/patch/parse.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/patch/reverse.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/util/array.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/util/distance-iterator.js","../node_modules/.pnpm/registry.npmmirror.com+diff@5.2.0/node_modules/diff/src/util/params.js"],"sourcesContent":["////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Actions represent the type of change to a location value.\n */\nexport enum Action {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Pop = \"POP\",\n\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Push = \"PUSH\",\n\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Replace = \"REPLACE\",\n}\n\n/**\n * The pathname, search, and hash values of a URL.\n */\nexport interface Path {\n  /**\n   * A URL pathname, beginning with a /.\n   */\n  pathname: string;\n\n  /**\n   * A URL search string, beginning with a ?.\n   */\n  search: string;\n\n  /**\n   * A URL fragment identifier, beginning with a #.\n   */\n  hash: string;\n}\n\n// TODO: (v7) Change the Location generic default from `any` to `unknown` and\n// remove Remix `useLocation` wrapper.\n\n/**\n * An entry in a history stack. A location contains information about the\n * URL path, as well as possibly some arbitrary state and a key.\n */\nexport interface Location<State = any> extends Path {\n  /**\n   * A value of arbitrary data associated with this location.\n   */\n  state: State;\n\n  /**\n   * A unique string associated with this location. May be used to safely store\n   * and retrieve data in some other storage API, like `localStorage`.\n   *\n   * Note: This value is always \"default\" on the initial location.\n   */\n  key: string;\n}\n\n/**\n * A change to the current location.\n */\nexport interface Update {\n  /**\n   * The action that triggered the change.\n   */\n  action: Action;\n\n  /**\n   * The new location.\n   */\n  location: Location;\n\n  /**\n   * The delta between this location and the former location in the history stack\n   */\n  delta: number | null;\n}\n\n/**\n * A function that receives notifications about location changes.\n */\nexport interface Listener {\n  (update: Update): void;\n}\n\n/**\n * Describes a location that is the destination of some navigation, either via\n * `history.push` or `history.replace`. This may be either a URL or the pieces\n * of a URL path.\n */\nexport type To = string | Partial<Path>;\n\n/**\n * A history is an interface to the navigation stack. The history serves as the\n * source of truth for the current location, as well as provides a set of\n * methods that may be used to change it.\n *\n * It is similar to the DOM's `window.history` object, but with a smaller, more\n * focused API.\n */\nexport interface History {\n  /**\n   * The last action that modified the current location. This will always be\n   * Action.Pop when a history instance is first created. This value is mutable.\n   */\n  readonly action: Action;\n\n  /**\n   * The current location. This value is mutable.\n   */\n  readonly location: Location;\n\n  /**\n   * Returns a valid href for the given `to` value that may be used as\n   * the value of an <a href> attribute.\n   *\n   * @param to - The destination URL\n   */\n  createHref(to: To): string;\n\n  /**\n   * Returns a URL for the given `to` value\n   *\n   * @param to - The destination URL\n   */\n  createURL(to: To): URL;\n\n  /**\n   * Encode a location the same way window.history would do (no-op for memory\n   * history) so we ensure our PUSH/REPLACE navigations for data routers\n   * behave the same as POP\n   *\n   * @param to Unencoded path\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * Pushes a new location onto the history stack, increasing its length by one.\n   * If there were any entries in the stack after the current one, they are\n   * lost.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  push(to: To, state?: any): void;\n\n  /**\n   * Replaces the current location in the history stack with a new one.  The\n   * location that was replaced will no longer be available.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  replace(to: To, state?: any): void;\n\n  /**\n   * Navigates `n` entries backward/forward in the history stack relative to the\n   * current index. For example, a \"back\" navigation would use go(-1).\n   *\n   * @param delta - The delta in the stack index\n   */\n  go(delta: number): void;\n\n  /**\n   * Sets up a listener that will be called whenever the current location\n   * changes.\n   *\n   * @param listener - A function that will be called when the location changes\n   * @returns unlisten - A function that may be used to stop listening\n   */\n  listen(listener: Listener): () => void;\n}\n\ntype HistoryState = {\n  usr: any;\n  key?: string;\n  idx: number;\n};\n\nconst PopStateEventType = \"popstate\";\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Memory History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A user-supplied object that describes a location. Used when providing\n * entries to `createMemoryHistory` via its `initialEntries` option.\n */\nexport type InitialEntry = string | Partial<Location>;\n\nexport type MemoryHistoryOptions = {\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n  v5Compat?: boolean;\n};\n\n/**\n * A memory history stores locations in memory. This is useful in stateful\n * environments where there is no web browser, such as node tests or React\n * Native.\n */\nexport interface MemoryHistory extends History {\n  /**\n   * The current index in the history stack.\n   */\n  readonly index: number;\n}\n\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nexport function createMemoryHistory(\n  options: MemoryHistoryOptions = {}\n): MemoryHistory {\n  let { initialEntries = [\"/\"], initialIndex, v5Compat = false } = options;\n  let entries: Location[]; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) =>\n    createMemoryLocation(\n      entry,\n      typeof entry === \"string\" ? null : entry.state,\n      index === 0 ? \"default\" : undefined\n    )\n  );\n  let index = clampIndex(\n    initialIndex == null ? entries.length - 1 : initialIndex\n  );\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  function clampIndex(n: number): number {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation(): Location {\n    return entries[index];\n  }\n  function createMemoryLocation(\n    to: To,\n    state: any = null,\n    key?: string\n  ): Location {\n    let location = createLocation(\n      entries ? getCurrentLocation().pathname : \"/\",\n      to,\n      state,\n      key\n    );\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in memory history: ${JSON.stringify(\n        to\n      )}`\n    );\n    return location;\n  }\n\n  function createHref(to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  let history: MemoryHistory = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to: To) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\",\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 1 });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 0 });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({ action, location: nextLocation, delta });\n      }\n    },\n    listen(fn: Listener) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    },\n  };\n\n  return history;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Browser History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A browser history stores the current location in regular URLs in a web\n * browser environment. This is the standard for most web apps and provides the\n * cleanest URLs the browser's address bar.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory\n */\nexport interface BrowserHistory extends UrlHistory {}\n\nexport type BrowserHistoryOptions = UrlHistoryOptions;\n\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nexport function createBrowserHistory(\n  options: BrowserHistoryOptions = {}\n): BrowserHistory {\n  function createBrowserLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let { pathname, search, hash } = window.location;\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createBrowserHref(window: Window, to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  return getUrlBasedHistory(\n    createBrowserLocation,\n    createBrowserHref,\n    null,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hash History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hash history stores the current location in the fragment identifier portion\n * of the URL in a web browser environment.\n *\n * This is ideal for apps that do not control the server for some reason\n * (because the fragment identifier is never sent to the server), including some\n * shared hosting environments that do not provide fine-grained controls over\n * which pages are served at which URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory\n */\nexport interface HashHistory extends UrlHistory {}\n\nexport type HashHistoryOptions = UrlHistoryOptions;\n\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nexport function createHashHistory(\n  options: HashHistoryOptions = {}\n): HashHistory {\n  function createHashLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\",\n    } = parsePath(window.location.hash.substr(1));\n\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path=\"*\">) since that matches internally against\n    // \"/*\" and we'd expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createHashHref(window: Window, to: To) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n\n  function validateHashLocation(location: Location, to: To) {\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n  }\n\n  return getUrlBasedHistory(\n    createHashLocation,\n    createHashHref,\n    validateHashLocation,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region UTILS\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @private\n */\nexport function invariant(value: boolean, message?: string): asserts value;\nexport function invariant<T>(\n  value: T | null | undefined,\n  message?: string\n): asserts value is T;\nexport function invariant(value: any, message?: string) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\nexport function warning(cond: any, message: string) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location: Location, index: number): HistoryState {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index,\n  };\n}\n\n/**\n * Creates a Location object with a unique key from the given Path\n */\nexport function createLocation(\n  current: string | Location,\n  to: To,\n  state: any = null,\n  key?: string\n): Readonly<Location> {\n  let location: Readonly<Location> = {\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\",\n    ...(typeof to === \"string\" ? parsePath(to) : to),\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: (to && (to as Location).key) || key || createKey(),\n  };\n  return location;\n}\n\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nexport function createPath({\n  pathname = \"/\",\n  search = \"\",\n  hash = \"\",\n}: Partial<Path>) {\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nexport function parsePath(path: string): Partial<Path> {\n  let parsedPath: Partial<Path> = {};\n\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport interface UrlHistory extends History {}\n\nexport type UrlHistoryOptions = {\n  window?: Window;\n  v5Compat?: boolean;\n};\n\nfunction getUrlBasedHistory(\n  getLocation: (window: Window, globalHistory: Window[\"history\"]) => Location,\n  createHref: (window: Window, to: To) => string,\n  validateLocation: ((location: Location, to: To) => void) | null,\n  options: UrlHistoryOptions = {}\n): UrlHistory {\n  let { window = document.defaultView!, v5Compat = false } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  let index = getIndex()!;\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, \"\");\n  }\n\n  function getIndex(): number {\n    let state = globalHistory.state || { idx: null };\n    return state.idx;\n  }\n\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({ action, location: history.location, delta });\n    }\n  }\n\n  function push(to: To, state?: any) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 1 });\n    }\n  }\n\n  function replace(to: To, state?: any) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 0 });\n    }\n  }\n\n  function createURL(to: To): URL {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base =\n      window.location.origin !== \"null\"\n        ? window.location.origin\n        : window.location.href;\n\n    let href = typeof to === \"string\" ? to : createPath(to);\n    // Treating this as a full URL will strip any trailing spaces so we need to\n    // pre-encode them since they might be part of a matching splat param from\n    // an ancestor route\n    href = href.replace(/ $/, \"%20\");\n    invariant(\n      base,\n      `No window.location.(origin|href) available to create URL for href: ${href}`\n    );\n    return new URL(href, base);\n  }\n\n  let history: History = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn: Listener) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash,\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    },\n  };\n\n  return history;\n}\n\n//#endregion\n","import type { Location, Path, To } from \"./history\";\nimport { invariant, parsePath, warning } from \"./history\";\n\n/**\n * Map of routeId -> data returned from a loader/action/error\n */\nexport interface RouteData {\n  [routeId: string]: any;\n}\n\nexport enum ResultType {\n  data = \"data\",\n  deferred = \"deferred\",\n  redirect = \"redirect\",\n  error = \"error\",\n}\n\n/**\n * Successful result from a loader or action\n */\nexport interface SuccessResult {\n  type: ResultType.data;\n  data: unknown;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Successful defer() result from a loader or action\n */\nexport interface DeferredResult {\n  type: ResultType.deferred;\n  deferredData: DeferredData;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Redirect result from a loader or action\n */\nexport interface RedirectResult {\n  type: ResultType.redirect;\n  // We keep the raw Response for redirects so we can return it verbatim\n  response: Response;\n}\n\n/**\n * Unsuccessful result from a loader or action\n */\nexport interface ErrorResult {\n  type: ResultType.error;\n  error: unknown;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Result from a loader or action - potentially successful or unsuccessful\n */\nexport type DataResult =\n  | SuccessResult\n  | DeferredResult\n  | RedirectResult\n  | ErrorResult;\n\n/**\n * Result from a loader or action called via dataStrategy\n */\nexport interface HandlerResult {\n  type: \"data\" | \"error\";\n  result: unknown; // data, Error, Response, DeferredData\n  status?: number;\n}\n\ntype LowerCaseFormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\ntype UpperCaseFormMethod = Uppercase<LowerCaseFormMethod>;\n\n/**\n * Users can specify either lowercase or uppercase form methods on `<Form>`,\n * useSubmit(), `<fetcher.Form>`, etc.\n */\nexport type HTMLFormMethod = LowerCaseFormMethod | UpperCaseFormMethod;\n\n/**\n * Active navigation/fetcher form methods are exposed in lowercase on the\n * RouterState\n */\nexport type FormMethod = LowerCaseFormMethod;\nexport type MutationFormMethod = Exclude<FormMethod, \"get\">;\n\n/**\n * In v7, active navigation/fetcher form methods are exposed in uppercase on the\n * RouterState.  This is to align with the normalization done via fetch().\n */\nexport type V7_FormMethod = UpperCaseFormMethod;\nexport type V7_MutationFormMethod = Exclude<V7_FormMethod, \"GET\">;\n\nexport type FormEncType =\n  | \"application/x-www-form-urlencoded\"\n  | \"multipart/form-data\"\n  | \"application/json\"\n  | \"text/plain\";\n\n// Thanks https://github.com/sindresorhus/type-fest!\ntype JsonObject = { [Key in string]: JsonValue } & {\n  [Key in string]?: JsonValue | undefined;\n};\ntype JsonArray = JsonValue[] | readonly JsonValue[];\ntype JsonPrimitive = string | number | boolean | null;\ntype JsonValue = JsonPrimitive | JsonObject | JsonArray;\n\n/**\n * @private\n * Internal interface to pass around for action submissions, not intended for\n * external consumption\n */\nexport type Submission =\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: FormData;\n      json: undefined;\n      text: undefined;\n    }\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: undefined;\n      json: JsonValue;\n      text: undefined;\n    }\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: undefined;\n      json: undefined;\n      text: string;\n    };\n\n/**\n * @private\n * Arguments passed to route loader/action functions.  Same for now but we keep\n * this as a private implementation detail in case they diverge in the future.\n */\ninterface DataFunctionArgs<Context> {\n  request: Request;\n  params: Params;\n  context?: Context;\n}\n\n// TODO: (v7) Change the defaults from any to unknown in and remove Remix wrappers:\n//   ActionFunction, ActionFunctionArgs, LoaderFunction, LoaderFunctionArgs\n//   Also, make them a type alias instead of an interface\n\n/**\n * Arguments passed to loader functions\n */\nexport interface LoaderFunctionArgs<Context = any>\n  extends DataFunctionArgs<Context> {}\n\n/**\n * Arguments passed to action functions\n */\nexport interface ActionFunctionArgs<Context = any>\n  extends DataFunctionArgs<Context> {}\n\n/**\n * Loaders and actions can return anything except `undefined` (`null` is a\n * valid return value if there is no data to return).  Responses are preferred\n * and will ease any future migration to Remix\n */\ntype DataFunctionValue = Response | NonNullable<unknown> | null;\n\ntype DataFunctionReturnValue = Promise<DataFunctionValue> | DataFunctionValue;\n\n/**\n * Route loader function signature\n */\nexport type LoaderFunction<Context = any> = {\n  (\n    args: LoaderFunctionArgs<Context>,\n    handlerCtx?: unknown\n  ): DataFunctionReturnValue;\n} & { hydrate?: boolean };\n\n/**\n * Route action function signature\n */\nexport interface ActionFunction<Context = any> {\n  (\n    args: ActionFunctionArgs<Context>,\n    handlerCtx?: unknown\n  ): DataFunctionReturnValue;\n}\n\n/**\n * Arguments passed to shouldRevalidate function\n */\nexport interface ShouldRevalidateFunctionArgs {\n  currentUrl: URL;\n  currentParams: AgnosticDataRouteMatch[\"params\"];\n  nextUrl: URL;\n  nextParams: AgnosticDataRouteMatch[\"params\"];\n  formMethod?: Submission[\"formMethod\"];\n  formAction?: Submission[\"formAction\"];\n  formEncType?: Submission[\"formEncType\"];\n  text?: Submission[\"text\"];\n  formData?: Submission[\"formData\"];\n  json?: Submission[\"json\"];\n  unstable_actionStatus?: number;\n  actionResult?: any;\n  defaultShouldRevalidate: boolean;\n}\n\n/**\n * Route shouldRevalidate function signature.  This runs after any submission\n * (navigation or fetcher), so we flatten the navigation/fetcher submission\n * onto the arguments.  It shouldn't matter whether it came from a navigation\n * or a fetcher, what really matters is the URLs and the formData since loaders\n * have to re-run based on the data models that were potentially mutated.\n */\nexport interface ShouldRevalidateFunction {\n  (args: ShouldRevalidateFunctionArgs): boolean;\n}\n\n/**\n * Function provided by the framework-aware layers to set `hasErrorBoundary`\n * from the framework-aware `errorElement` prop\n *\n * @deprecated Use `mapRouteProperties` instead\n */\nexport interface DetectErrorBoundaryFunction {\n  (route: AgnosticRouteObject): boolean;\n}\n\nexport interface DataStrategyMatch\n  extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {\n  shouldLoad: boolean;\n  resolve: (\n    handlerOverride?: (\n      handler: (ctx?: unknown) => DataFunctionReturnValue\n    ) => Promise<HandlerResult>\n  ) => Promise<HandlerResult>;\n}\n\nexport interface DataStrategyFunctionArgs<Context = any>\n  extends DataFunctionArgs<Context> {\n  matches: DataStrategyMatch[];\n}\n\nexport interface DataStrategyFunction {\n  (args: DataStrategyFunctionArgs): Promise<HandlerResult[]>;\n}\n\n/**\n * Function provided by the framework-aware layers to set any framework-specific\n * properties from framework-agnostic properties\n */\nexport interface MapRoutePropertiesFunction {\n  (route: AgnosticRouteObject): {\n    hasErrorBoundary: boolean;\n  } & Record<string, any>;\n}\n\n/**\n * Keys we cannot change from within a lazy() function. We spread all other keys\n * onto the route. Either they're meaningful to the router, or they'll get\n * ignored.\n */\nexport type ImmutableRouteKey =\n  | \"lazy\"\n  | \"caseSensitive\"\n  | \"path\"\n  | \"id\"\n  | \"index\"\n  | \"children\";\n\nexport const immutableRouteKeys = new Set<ImmutableRouteKey>([\n  \"lazy\",\n  \"caseSensitive\",\n  \"path\",\n  \"id\",\n  \"index\",\n  \"children\",\n]);\n\ntype RequireOne<T, Key = keyof T> = Exclude<\n  {\n    [K in keyof T]: K extends Key ? Omit<T, K> & Required<Pick<T, K>> : never;\n  }[keyof T],\n  undefined\n>;\n\n/**\n * lazy() function to load a route definition, which can add non-matching\n * related properties to a route\n */\nexport interface LazyRouteFunction<R extends AgnosticRouteObject> {\n  (): Promise<RequireOne<Omit<R, ImmutableRouteKey>>>;\n}\n\n/**\n * Base RouteObject with common props shared by all types of routes\n */\ntype AgnosticBaseRouteObject = {\n  caseSensitive?: boolean;\n  path?: string;\n  id?: string;\n  loader?: LoaderFunction | boolean;\n  action?: ActionFunction | boolean;\n  hasErrorBoundary?: boolean;\n  shouldRevalidate?: ShouldRevalidateFunction;\n  handle?: any;\n  lazy?: LazyRouteFunction<AgnosticBaseRouteObject>;\n};\n\n/**\n * Index routes must not have children\n */\nexport type AgnosticIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: undefined;\n  index: true;\n};\n\n/**\n * Non-index routes may have children, but cannot have index\n */\nexport type AgnosticNonIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: AgnosticRouteObject[];\n  index?: false;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport type AgnosticRouteObject =\n  | AgnosticIndexRouteObject\n  | AgnosticNonIndexRouteObject;\n\nexport type AgnosticDataIndexRouteObject = AgnosticIndexRouteObject & {\n  id: string;\n};\n\nexport type AgnosticDataNonIndexRouteObject = AgnosticNonIndexRouteObject & {\n  children?: AgnosticDataRouteObject[];\n  id: string;\n};\n\n/**\n * A data route object, which is just a RouteObject with a required unique ID\n */\nexport type AgnosticDataRouteObject =\n  | AgnosticDataIndexRouteObject\n  | AgnosticDataNonIndexRouteObject;\n\nexport type RouteManifest = Record<string, AgnosticDataRouteObject | undefined>;\n\n// Recursive helper for finding path parameters in the absence of wildcards\ntype _PathParam<Path extends string> =\n  // split path into individual path segments\n  Path extends `${infer L}/${infer R}`\n    ? _PathParam<L> | _PathParam<R>\n    : // find params after `:`\n    Path extends `:${infer Param}`\n    ? Param extends `${infer Optional}?`\n      ? Optional\n      : Param\n    : // otherwise, there aren't any params present\n      never;\n\n/**\n * Examples:\n * \"/a/b/*\" -> \"*\"\n * \":a\" -> \"a\"\n * \"/a/:b\" -> \"b\"\n * \"/a/blahblahblah:b\" -> \"b\"\n * \"/:a/:b\" -> \"a\" | \"b\"\n * \"/:a/b/:c/*\" -> \"a\" | \"c\" | \"*\"\n */\nexport type PathParam<Path extends string> =\n  // check if path is just a wildcard\n  Path extends \"*\" | \"/*\"\n    ? \"*\"\n    : // look for wildcard at the end of the path\n    Path extends `${infer Rest}/*`\n    ? \"*\" | _PathParam<Rest>\n    : // look for params in the absence of wildcards\n      _PathParam<Path>;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise, return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  // if you could not find path params, fallback to `string`\n  [PathParam<Segment>] extends [never] ? string : PathParam<Segment>;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface AgnosticRouteMatch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObjectType;\n}\n\nexport interface AgnosticDataRouteMatch\n  extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {}\n\nfunction isIndexRoute(\n  route: AgnosticRouteObject\n): route is AgnosticIndexRouteObject {\n  return route.index === true;\n}\n\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nexport function convertRoutesToDataRoutes(\n  routes: AgnosticRouteObject[],\n  mapRouteProperties: MapRoutePropertiesFunction,\n  parentPath: number[] = [],\n  manifest: RouteManifest = {}\n): AgnosticDataRouteObject[] {\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(\n      route.index !== true || !route.children,\n      `Cannot specify children on an index route`\n    );\n    invariant(\n      !manifest[id],\n      `Found a route id collision on id \"${id}\".  Route ` +\n        \"id's must be globally unique within Data Router usages\"\n    );\n\n    if (isIndexRoute(route)) {\n      let indexRoute: AgnosticDataIndexRouteObject = {\n        ...route,\n        ...mapRouteProperties(route),\n        id,\n      };\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute: AgnosticDataNonIndexRouteObject = {\n        ...route,\n        ...mapRouteProperties(route),\n        id,\n        children: undefined,\n      };\n      manifest[id] = pathOrLayoutRoute;\n\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(\n          route.children,\n          mapRouteProperties,\n          treePath,\n          manifest\n        );\n      }\n\n      return pathOrLayoutRoute;\n    }\n  });\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nexport function matchRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): AgnosticRouteMatch<string, RouteObjectType>[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won't be\n    // encoded here but there also shouldn't be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    let decoded = decodePath(pathname);\n    matches = matchRouteBranch<string, RouteObjectType>(branches[i], decoded);\n  }\n\n  return matches;\n}\n\nexport interface UIMatch<Data = unknown, Handle = unknown> {\n  id: string;\n  pathname: string;\n  params: AgnosticRouteMatch[\"params\"];\n  data: Data;\n  handle: Handle;\n}\n\nexport function convertRouteMatchToUiMatch(\n  match: AgnosticDataRouteMatch,\n  loaderData: RouteData\n): UIMatch {\n  let { route, pathname, params } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle,\n  };\n}\n\ninterface RouteMeta<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObjectType;\n}\n\ninterface RouteBranch<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta<RouteObjectType>[];\n}\n\nfunction flattenRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  branches: RouteBranch<RouteObjectType>[] = [],\n  parentsMeta: RouteMeta<RouteObjectType>[] = [],\n  parentPath = \"\"\n): RouteBranch<RouteObjectType>[] {\n  let flattenRoute = (\n    route: RouteObjectType,\n    index: number,\n    relativePath?: string\n  ) => {\n    let meta: RouteMeta<RouteObjectType> = {\n      relativePath:\n        relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta,\n    });\n  };\n  routes.forEach((route, index) => {\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !route.path?.includes(\"?\")) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n\n  return branches;\n}\n\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path: string): string[] {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n\n  let [first, ...rest] = segments;\n\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n\n  let result: string[] = [];\n\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(\n    ...restExploded.map((subpath) =>\n      subpath === \"\" ? required : [required, subpath].join(\"/\")\n    )\n  );\n\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map((exploded) =>\n    path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded\n  );\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:[\\w-]+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  branch: RouteBranch<RouteObjectType>,\n  pathname: string\n): AgnosticRouteMatch<ParamKey, RouteObjectType>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: AgnosticRouteMatch<ParamKey, RouteObjectType>[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams as Params<ParamKey>,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nexport function generatePath<Path extends string>(\n  originalPath: Path,\n  params: {\n    [key in PathParam<Path>]: string | null;\n  } = {} as any\n): string {\n  let path: string = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(\n      false,\n      `Route path \"${path}\" will be treated as if it were ` +\n        `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n        `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n        `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n    );\n    path = path.replace(/\\*$/, \"/*\") as Path;\n  }\n\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n\n  const stringify = (p: any) =>\n    p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n\n  const segments = path\n    .split(/\\/+/)\n    .map((segment, index, array) => {\n      const isLastSegment = index === array.length - 1;\n\n      // only apply the splat if it's the last segment\n      if (isLastSegment && segment === \"*\") {\n        const star = \"*\" as PathParam<Path>;\n        // Apply the splat\n        return stringify(params[star]);\n      }\n\n      const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n      if (keyMatch) {\n        const [, key, optional] = keyMatch;\n        let param = params[key as PathParam<Path>];\n        invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n        return stringify(param);\n      }\n\n      // Remove any optional markers from optional static segments\n      return segment.replace(/\\?$/g, \"\");\n    })\n    // Remove empty segments\n    .filter((segment) => !!segment);\n\n  return prefix + segments.join(\"/\");\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, compiledParams] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = compiledParams.reduce<Mutable<Params>>(\n    (memo, { paramName, isOptional }, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      const value = captureGroups[index];\n      if (isOptional && !value) {\n        memo[paramName] = undefined;\n      } else {\n        memo[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n      }\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\ntype CompiledPathParam = { paramName: string; isOptional?: boolean };\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, CompiledPathParam[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let params: CompiledPathParam[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(\n        /\\/:([\\w-]+)(\\?)?/g,\n        (_: string, paramName: string, isOptional) => {\n          params.push({ paramName, isOptional: isOptional != null });\n          return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n        }\n      );\n\n  if (path.endsWith(\"*\")) {\n    params.push({ paramName: \"*\" });\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else {\n    // Nothing to match for \"\" or \"/\"\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, params];\n}\n\nfunction decodePath(value: string) {\n  try {\n    return value\n      .split(\"/\")\n      .map((v) => decodeURIComponent(v).replace(/\\//g, \"%2F\"))\n      .join(\"/\");\n  } catch (error) {\n    warning(\n      false,\n      `The URL path \"${value}\" could not be decoded because it is is a ` +\n        `malformed URL segment. This is probably due to a bad percent ` +\n        `encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * @private\n */\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\")\n    ? basename.length - 1\n    : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(startIndex) || \"/\";\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction getInvalidPathError(\n  char: string,\n  field: string,\n  dest: string,\n  path: Partial<Path>\n) {\n  return (\n    `Cannot include a '${char}' character in a manually specified ` +\n    `\\`to.${field}\\` field [${JSON.stringify(\n      path\n    )}].  Please separate it out to the ` +\n    `\\`to.${dest}\\` field. Alternatively you may provide the full path as ` +\n    `a string in <Link to=\"...\"> and the router will parse it for you.`\n  );\n}\n\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nexport function getPathContributingMatches<\n  T extends AgnosticRouteMatch = AgnosticRouteMatch\n>(matches: T[]) {\n  return matches.filter(\n    (match, index) =>\n      index === 0 || (match.route.path && match.route.path.length > 0)\n  );\n}\n\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nexport function getResolveToMatches<\n  T extends AgnosticRouteMatch = AgnosticRouteMatch\n>(matches: T[], v7_relativeSplatPath: boolean) {\n  let pathMatches = getPathContributingMatches(matches);\n\n  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf\n  // match so we include splat values for \".\" links.  See:\n  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329\n  if (v7_relativeSplatPath) {\n    return pathMatches.map((match, idx) =>\n      idx === matches.length - 1 ? match.pathname : match.pathnameBase\n    );\n  }\n\n  return pathMatches.map((match) => match.pathnameBase);\n}\n\n/**\n * @private\n */\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string,\n  isPathRelative = false\n): Path {\n  let to: Partial<Path>;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = { ...toArg };\n\n    invariant(\n      !to.pathname || !to.pathname.includes(\"?\"),\n      getInvalidPathError(\"?\", \"pathname\", \"search\", to)\n    );\n    invariant(\n      !to.pathname || !to.pathname.includes(\"#\"),\n      getInvalidPathError(\"#\", \"pathname\", \"hash\", to)\n    );\n    invariant(\n      !to.search || !to.search.includes(\"#\"),\n      getInvalidPathError(\"#\", \"search\", \"hash\", to)\n    );\n  }\n\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n\n  let from: string;\n\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    // With relative=\"route\" (the default), each leading .. segment means\n    // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n    // difference from how <a href> works and a major reason we call this a\n    // \"to\" value instead of a \"href\".\n    if (!isPathRelative && toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash =\n    toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash =\n    (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (\n    !path.pathname.endsWith(\"/\") &&\n    (hasExplicitTrailingSlash || hasCurrentTrailingSlash)\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\n/**\n * @private\n */\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\n/**\n * @private\n */\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\n/**\n * @private\n */\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\n/**\n * @private\n */\nexport const normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\n/**\n * @private\n */\nexport const normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\nexport type JsonFunction = <Data>(\n  data: Data,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nexport const json: JsonFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n\n  return new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers,\n  });\n};\n\nexport interface TrackedPromise extends Promise<any> {\n  _tracked?: boolean;\n  _data?: any;\n  _error?: any;\n}\n\nexport class AbortedDeferredError extends Error {}\n\nexport class DeferredData {\n  private pendingKeysSet: Set<string> = new Set<string>();\n  private controller: AbortController;\n  private abortPromise: Promise<void>;\n  private unlistenAbortSignal: () => void;\n  private subscribers: Set<(aborted: boolean, settledKey?: string) => void> =\n    new Set();\n  data: Record<string, unknown>;\n  init?: ResponseInit;\n  deferredKeys: string[] = [];\n\n  constructor(data: Record<string, unknown>, responseInit?: ResponseInit) {\n    invariant(\n      data && typeof data === \"object\" && !Array.isArray(data),\n      \"defer() only accepts plain objects\"\n    );\n\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject: (e: AbortedDeferredError) => void;\n    this.abortPromise = new Promise((_, r) => (reject = r));\n    this.controller = new AbortController();\n    let onAbort = () =>\n      reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () =>\n      this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n\n    this.data = Object.entries(data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: this.trackPromise(key, value),\n        }),\n      {}\n    );\n\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n\n    this.init = responseInit;\n  }\n\n  private trackPromise(\n    key: string,\n    value: Promise<unknown> | unknown\n  ): TrackedPromise | unknown {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise: TrackedPromise = Promise.race([value, this.abortPromise]).then(\n      (data) => this.onSettle(promise, key, undefined, data as unknown),\n      (error) => this.onSettle(promise, key, error as unknown)\n    );\n\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n\n    Object.defineProperty(promise, \"_tracked\", { get: () => true });\n    return promise;\n  }\n\n  private onSettle(\n    promise: TrackedPromise,\n    key: string,\n    error: unknown,\n    data?: unknown\n  ): unknown {\n    if (\n      this.controller.signal.aborted &&\n      error instanceof AbortedDeferredError\n    ) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      return Promise.reject(error);\n    }\n\n    this.pendingKeysSet.delete(key);\n\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\n        `Deferred data for key \"${key}\" resolved/rejected with \\`undefined\\`, ` +\n          `you must resolve/reject with a value or \\`null\\`.`\n      );\n      Object.defineProperty(promise, \"_error\", { get: () => undefinedError });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n\n    Object.defineProperty(promise, \"_data\", { get: () => data });\n    this.emit(false, key);\n    return data;\n  }\n\n  private emit(aborted: boolean, settledKey?: string) {\n    this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));\n  }\n\n  subscribe(fn: (aborted: boolean, settledKey?: string) => void) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n\n  async resolveData(signal: AbortSignal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise((resolve) => {\n        this.subscribe((aborted) => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n\n  get unwrappedData() {\n    invariant(\n      this.data !== null && this.done,\n      \"Can only unwrap data on initialized and settled deferreds\"\n    );\n\n    return Object.entries(this.data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: unwrapTrackedPromise(value),\n        }),\n      {}\n    );\n  }\n\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\n\nfunction isTrackedPromise(value: any): value is TrackedPromise {\n  return (\n    value instanceof Promise && (value as TrackedPromise)._tracked === true\n  );\n}\n\nfunction unwrapTrackedPromise(value: any) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\n\nexport type DeferFunction = (\n  data: Record<string, unknown>,\n  init?: number | ResponseInit\n) => DeferredData;\n\nexport const defer: DeferFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  return new DeferredData(data, responseInit);\n};\n\nexport type RedirectFunction = (\n  url: string,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirect: RedirectFunction = (url, init = 302) => {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n\n  return new Response(null, {\n    ...responseInit,\n    headers,\n  });\n};\n\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirectDocument: RedirectFunction = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\n\nexport type ErrorResponse = {\n  status: number;\n  statusText: string;\n  data: any;\n};\n\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */\nexport class ErrorResponseImpl implements ErrorResponse {\n  status: number;\n  statusText: string;\n  data: any;\n  private error?: Error;\n  private internal: boolean;\n\n  constructor(\n    status: number,\n    statusText: string | undefined,\n    data: any,\n    internal = false\n  ) {\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nexport function isRouteErrorResponse(error: any): error is ErrorResponse {\n  return (\n    error != null &&\n    typeof error.status === \"number\" &&\n    typeof error.statusText === \"string\" &&\n    typeof error.internal === \"boolean\" &&\n    \"data\" in error\n  );\n}\n","import type { History, Location, Path, To } from \"./history\";\nimport {\n  Action as HistoryAction,\n  createLocation,\n  createPath,\n  invariant,\n  parsePath,\n  warning,\n} from \"./history\";\nimport type {\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteObject,\n  DataStrategyMatch,\n  AgnosticRouteObject,\n  DataResult,\n  DataStrategyFunction,\n  DataStrategyFunctionArgs,\n  DeferredData,\n  DeferredResult,\n  DetectErrorBoundaryFunction,\n  ErrorResult,\n  FormEncType,\n  FormMethod,\n  HTMLFormMethod,\n  HandlerResult,\n  ImmutableRouteKey,\n  MapRoutePropertiesFunction,\n  MutationFormMethod,\n  RedirectResult,\n  RouteData,\n  RouteManifest,\n  ShouldRevalidateFunctionArgs,\n  Submission,\n  SuccessResult,\n  UIMatch,\n  V7_FormMethod,\n  V7_MutationFormMethod,\n} from \"./utils\";\nimport {\n  ErrorResponseImpl,\n  ResultType,\n  convertRouteMatchToUiMatch,\n  convertRoutesToDataRoutes,\n  getPathContributingMatches,\n  getResolveToMatches,\n  immutableRouteKeys,\n  isRouteErrorResponse,\n  joinPaths,\n  matchRoutes,\n  resolveTo,\n  stripBasename,\n} from \"./utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Router instance manages all navigation and data loading/mutations\n */\nexport interface Router {\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the basename for the router\n   */\n  get basename(): RouterInit[\"basename\"];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the future config for the router\n   */\n  get future(): FutureConfig;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the current state of the router\n   */\n  get state(): RouterState;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the routes for this router instance\n   */\n  get routes(): AgnosticDataRouteObject[];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the window associated with the router\n   */\n  get window(): RouterInit[\"window\"];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Initialize the router, including adding history listeners and kicking off\n   * initial data fetches.  Returns a function to cleanup listeners and abort\n   * any in-progress loads\n   */\n  initialize(): Router;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Subscribe to router.state updates\n   *\n   * @param fn function to call with the new state\n   */\n  subscribe(fn: RouterSubscriber): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Enable scroll restoration behavior in the router\n   *\n   * @param savedScrollPositions Object that will manage positions, in case\n   *                             it's being restored from sessionStorage\n   * @param getScrollPosition    Function to get the active Y scroll position\n   * @param getKey               Function to get the key to use for restoration\n   */\n  enableScrollRestoration(\n    savedScrollPositions: Record<string, number>,\n    getScrollPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Navigate forward/backward in the history stack\n   * @param to Delta to move in the history stack\n   */\n  navigate(to: number): Promise<void>;\n\n  /**\n   * Navigate to the given path\n   * @param to Path to navigate to\n   * @param opts Navigation options (method, submission, etc.)\n   */\n  navigate(to: To | null, opts?: RouterNavigateOptions): Promise<void>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a fetcher load/submission\n   *\n   * @param key     Fetcher key\n   * @param routeId Route that owns the fetcher\n   * @param href    href to fetch\n   * @param opts    Fetcher options, (method, submission, etc.)\n   */\n  fetch(\n    key: string,\n    routeId: string,\n    href: string | null,\n    opts?: RouterFetchOptions\n  ): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a revalidation of all current route loaders and fetcher loads\n   */\n  revalidate(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to create an href for the given location\n   * @param location\n   */\n  createHref(location: Location | URL): string;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to URL encode a destination path according to the internal\n   * history implementation\n   * @param to\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get/create a fetcher for the given key\n   * @param key\n   */\n  getFetcher<TData = any>(key: string): Fetcher<TData>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete the fetcher for a given key\n   * @param key\n   */\n  deleteFetcher(key: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Cleanup listeners and abort any in-progress loads\n   */\n  dispose(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get a navigation blocker\n   * @param key The identifier for the blocker\n   * @param fn The blocker function implementation\n   */\n  getBlocker(key: string, fn: BlockerFunction): Blocker;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete a navigation blocker\n   * @param key The identifier for the blocker\n   */\n  deleteBlocker(key: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * HMR needs to pass in-flight route updates to React Router\n   * TODO: Replace this with granular route update APIs (addRoute, updateRoute, deleteRoute)\n   */\n  _internalSetRoutes(routes: AgnosticRouteObject[]): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal fetch AbortControllers accessed by unit tests\n   */\n  _internalFetchControllers: Map<string, AbortController>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal pending DeferredData instances accessed by unit tests\n   */\n  _internalActiveDeferreds: Map<string, DeferredData>;\n}\n\n/**\n * State maintained internally by the router.  During a navigation, all states\n * reflect the the \"old\" location unless otherwise noted.\n */\nexport interface RouterState {\n  /**\n   * The action of the most recent navigation\n   */\n  historyAction: HistoryAction;\n\n  /**\n   * The current location reflected by the router\n   */\n  location: Location;\n\n  /**\n   * The current set of route matches\n   */\n  matches: AgnosticDataRouteMatch[];\n\n  /**\n   * Tracks whether we've completed our initial data load\n   */\n  initialized: boolean;\n\n  /**\n   * Current scroll position we should start at for a new view\n   *  - number -> scroll position to restore to\n   *  - false -> do not restore scroll at all (used during submissions)\n   *  - null -> don't have a saved position, scroll to hash or top of page\n   */\n  restoreScrollPosition: number | false | null;\n\n  /**\n   * Indicate whether this navigation should skip resetting the scroll position\n   * if we are unable to restore the scroll position\n   */\n  preventScrollReset: boolean;\n\n  /**\n   * Tracks the state of the current navigation\n   */\n  navigation: Navigation;\n\n  /**\n   * Tracks any in-progress revalidations\n   */\n  revalidation: RevalidationState;\n\n  /**\n   * Data from the loaders for the current matches\n   */\n  loaderData: RouteData;\n\n  /**\n   * Data from the action for the current matches\n   */\n  actionData: RouteData | null;\n\n  /**\n   * Errors caught from loaders for the current matches\n   */\n  errors: RouteData | null;\n\n  /**\n   * Map of current fetchers\n   */\n  fetchers: Map<string, Fetcher>;\n\n  /**\n   * Map of current blockers\n   */\n  blockers: Map<string, Blocker>;\n}\n\n/**\n * Data that can be passed into hydrate a Router from SSR\n */\nexport type HydrationState = Partial<\n  Pick<RouterState, \"loaderData\" | \"actionData\" | \"errors\">\n>;\n\n/**\n * Future flags to toggle new feature behavior\n */\nexport interface FutureConfig {\n  v7_fetcherPersist: boolean;\n  v7_normalizeFormMethod: boolean;\n  v7_partialHydration: boolean;\n  v7_prependBasename: boolean;\n  v7_relativeSplatPath: boolean;\n  unstable_skipActionErrorRevalidation: boolean;\n}\n\n/**\n * Initialization options for createRouter\n */\nexport interface RouterInit {\n  routes: AgnosticRouteObject[];\n  history: History;\n  basename?: string;\n  /**\n   * @deprecated Use `mapRouteProperties` instead\n   */\n  detectErrorBoundary?: DetectErrorBoundaryFunction;\n  mapRouteProperties?: MapRoutePropertiesFunction;\n  future?: Partial<FutureConfig>;\n  hydrationData?: HydrationState;\n  window?: Window;\n  unstable_dataStrategy?: DataStrategyFunction;\n}\n\n/**\n * State returned from a server-side query() call\n */\nexport interface StaticHandlerContext {\n  basename: Router[\"basename\"];\n  location: RouterState[\"location\"];\n  matches: RouterState[\"matches\"];\n  loaderData: RouterState[\"loaderData\"];\n  actionData: RouterState[\"actionData\"];\n  errors: RouterState[\"errors\"];\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n  actionHeaders: Record<string, Headers>;\n  activeDeferreds: Record<string, DeferredData> | null;\n  _deepestRenderedBoundaryId?: string | null;\n}\n\n/**\n * A StaticHandler instance manages a singular SSR navigation/fetch event\n */\nexport interface StaticHandler {\n  dataRoutes: AgnosticDataRouteObject[];\n  query(\n    request: Request,\n    opts?: {\n      requestContext?: unknown;\n      skipLoaderErrorBubbling?: boolean;\n      unstable_dataStrategy?: DataStrategyFunction;\n    }\n  ): Promise<StaticHandlerContext | Response>;\n  queryRoute(\n    request: Request,\n    opts?: {\n      routeId?: string;\n      requestContext?: unknown;\n      unstable_dataStrategy?: DataStrategyFunction;\n    }\n  ): Promise<any>;\n}\n\ntype ViewTransitionOpts = {\n  currentLocation: Location;\n  nextLocation: Location;\n};\n\n/**\n * Subscriber function signature for changes to router state\n */\nexport interface RouterSubscriber {\n  (\n    state: RouterState,\n    opts: {\n      deletedFetchers: string[];\n      unstable_viewTransitionOpts?: ViewTransitionOpts;\n      unstable_flushSync: boolean;\n    }\n  ): void;\n}\n\n/**\n * Function signature for determining the key to be used in scroll restoration\n * for a given location\n */\nexport interface GetScrollRestorationKeyFunction {\n  (location: Location, matches: UIMatch[]): string | null;\n}\n\n/**\n * Function signature for determining the current scroll position\n */\nexport interface GetScrollPositionFunction {\n  (): number;\n}\n\nexport type RelativeRoutingType = \"route\" | \"path\";\n\n// Allowed for any navigation or fetch\ntype BaseNavigateOrFetchOptions = {\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n  unstable_flushSync?: boolean;\n};\n\n// Only allowed for navigations\ntype BaseNavigateOptions = BaseNavigateOrFetchOptions & {\n  replace?: boolean;\n  state?: any;\n  fromRouteId?: string;\n  unstable_viewTransition?: boolean;\n};\n\n// Only allowed for submission navigations\ntype BaseSubmissionOptions = {\n  formMethod?: HTMLFormMethod;\n  formEncType?: FormEncType;\n} & (\n  | { formData: FormData; body?: undefined }\n  | { formData?: undefined; body: any }\n);\n\n/**\n * Options for a navigate() call for a normal (non-submission) navigation\n */\ntype LinkNavigateOptions = BaseNavigateOptions;\n\n/**\n * Options for a navigate() call for a submission navigation\n */\ntype SubmissionNavigateOptions = BaseNavigateOptions & BaseSubmissionOptions;\n\n/**\n * Options to pass to navigate() for a navigation\n */\nexport type RouterNavigateOptions =\n  | LinkNavigateOptions\n  | SubmissionNavigateOptions;\n\n/**\n * Options for a fetch() load\n */\ntype LoadFetchOptions = BaseNavigateOrFetchOptions;\n\n/**\n * Options for a fetch() submission\n */\ntype SubmitFetchOptions = BaseNavigateOrFetchOptions & BaseSubmissionOptions;\n\n/**\n * Options to pass to fetch()\n */\nexport type RouterFetchOptions = LoadFetchOptions | SubmitFetchOptions;\n\n/**\n * Potential states for state.navigation\n */\nexport type NavigationStates = {\n  Idle: {\n    state: \"idle\";\n    location: undefined;\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    formData: undefined;\n    json: undefined;\n    text: undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    location: Location;\n    formMethod: Submission[\"formMethod\"] | undefined;\n    formAction: Submission[\"formAction\"] | undefined;\n    formEncType: Submission[\"formEncType\"] | undefined;\n    formData: Submission[\"formData\"] | undefined;\n    json: Submission[\"json\"] | undefined;\n    text: Submission[\"text\"] | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    location: Location;\n    formMethod: Submission[\"formMethod\"];\n    formAction: Submission[\"formAction\"];\n    formEncType: Submission[\"formEncType\"];\n    formData: Submission[\"formData\"];\n    json: Submission[\"json\"];\n    text: Submission[\"text\"];\n  };\n};\n\nexport type Navigation = NavigationStates[keyof NavigationStates];\n\nexport type RevalidationState = \"idle\" | \"loading\";\n\n/**\n * Potential states for fetchers\n */\ntype FetcherStates<TData = any> = {\n  Idle: {\n    state: \"idle\";\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    text: undefined;\n    formData: undefined;\n    json: undefined;\n    data: TData | undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    formMethod: Submission[\"formMethod\"] | undefined;\n    formAction: Submission[\"formAction\"] | undefined;\n    formEncType: Submission[\"formEncType\"] | undefined;\n    text: Submission[\"text\"] | undefined;\n    formData: Submission[\"formData\"] | undefined;\n    json: Submission[\"json\"] | undefined;\n    data: TData | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    formMethod: Submission[\"formMethod\"];\n    formAction: Submission[\"formAction\"];\n    formEncType: Submission[\"formEncType\"];\n    text: Submission[\"text\"];\n    formData: Submission[\"formData\"];\n    json: Submission[\"json\"];\n    data: TData | undefined;\n  };\n};\n\nexport type Fetcher<TData = any> =\n  FetcherStates<TData>[keyof FetcherStates<TData>];\n\ninterface BlockerBlocked {\n  state: \"blocked\";\n  reset(): void;\n  proceed(): void;\n  location: Location;\n}\n\ninterface BlockerUnblocked {\n  state: \"unblocked\";\n  reset: undefined;\n  proceed: undefined;\n  location: undefined;\n}\n\ninterface BlockerProceeding {\n  state: \"proceeding\";\n  reset: undefined;\n  proceed: undefined;\n  location: Location;\n}\n\nexport type Blocker = BlockerUnblocked | BlockerBlocked | BlockerProceeding;\n\nexport type BlockerFunction = (args: {\n  currentLocation: Location;\n  nextLocation: Location;\n  historyAction: HistoryAction;\n}) => boolean;\n\ninterface ShortCircuitable {\n  /**\n   * startNavigation does not need to complete the navigation because we\n   * redirected or got interrupted\n   */\n  shortCircuited?: boolean;\n}\n\ntype PendingActionResult = [string, SuccessResult | ErrorResult];\n\ninterface HandleActionResult extends ShortCircuitable {\n  /**\n   * Tuple for the returned or thrown value from the current action.  The routeId\n   * is the action route for success and the bubbled boundary route for errors.\n   */\n  pendingActionResult?: PendingActionResult;\n}\n\ninterface HandleLoadersResult extends ShortCircuitable {\n  /**\n   * loaderData returned from the current set of loaders\n   */\n  loaderData?: RouterState[\"loaderData\"];\n  /**\n   * errors thrown from the current set of loaders\n   */\n  errors?: RouterState[\"errors\"];\n}\n\n/**\n * Cached info for active fetcher.load() instances so they can participate\n * in revalidation\n */\ninterface FetchLoadMatch {\n  routeId: string;\n  path: string;\n}\n\n/**\n * Identified fetcher.load() calls that need to be revalidated\n */\ninterface RevalidatingFetcher extends FetchLoadMatch {\n  key: string;\n  match: AgnosticDataRouteMatch | null;\n  matches: AgnosticDataRouteMatch[] | null;\n  controller: AbortController | null;\n}\n\nconst validMutationMethodsArr: MutationFormMethod[] = [\n  \"post\",\n  \"put\",\n  \"patch\",\n  \"delete\",\n];\nconst validMutationMethods = new Set<MutationFormMethod>(\n  validMutationMethodsArr\n);\n\nconst validRequestMethodsArr: FormMethod[] = [\n  \"get\",\n  ...validMutationMethodsArr,\n];\nconst validRequestMethods = new Set<FormMethod>(validRequestMethodsArr);\n\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\n\nexport const IDLE_NAVIGATION: NavigationStates[\"Idle\"] = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined,\n};\n\nexport const IDLE_FETCHER: FetcherStates[\"Idle\"] = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined,\n};\n\nexport const IDLE_BLOCKER: BlockerUnblocked = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined,\n};\n\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\nconst defaultMapRouteProperties: MapRoutePropertiesFunction = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary),\n});\n\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Create a router and listen to history POP navigations\n */\nexport function createRouter(init: RouterInit): Router {\n  const routerWindow = init.window\n    ? init.window\n    : typeof window !== \"undefined\"\n    ? window\n    : undefined;\n  const isBrowser =\n    typeof routerWindow !== \"undefined\" &&\n    typeof routerWindow.document !== \"undefined\" &&\n    typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n\n  invariant(\n    init.routes.length > 0,\n    \"You must provide a non-empty routes array to createRouter\"\n  );\n\n  let mapRouteProperties: MapRoutePropertiesFunction;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route),\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n\n  // Routes keyed by ID\n  let manifest: RouteManifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(\n    init.routes,\n    mapRouteProperties,\n    undefined,\n    manifest\n  );\n  let inFlightDataRoutes: AgnosticDataRouteObject[] | undefined;\n  let basename = init.basename || \"/\";\n  let dataStrategyImpl = init.unstable_dataStrategy || defaultDataStrategy;\n  // Config driven behavior flags\n  let future: FutureConfig = {\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_partialHydration: false,\n    v7_prependBasename: false,\n    v7_relativeSplatPath: false,\n    unstable_skipActionErrorRevalidation: false,\n    ...init.future,\n  };\n  // Cleanup function for history\n  let unlistenHistory: (() => void) | null = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set<RouterSubscriber>();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions: Record<string, number> | null = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey: GetScrollRestorationKeyFunction | null = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition: GetScrollPositionFunction | null = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors: RouteData | null = null;\n\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname,\n    });\n    let { matches, route } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = { [route.id]: error };\n  }\n\n  let initialized: boolean;\n  let hasLazyRoutes = initialMatches.some((m) => m.route.lazy);\n  let hasLoaders = initialMatches.some((m) => m.route.loader);\n  if (hasLazyRoutes) {\n    // All initialMatches need to be loaded before we're ready.  If we have lazy\n    // functions around still then we'll need to run them in initialize()\n    initialized = false;\n  } else if (!hasLoaders) {\n    // If we've got no loaders to run, then we're good to go\n    initialized = true;\n  } else if (future.v7_partialHydration) {\n    // If partial hydration is enabled, we're initialized so long as we were\n    // provided with hydrationData for every route with a loader, and no loaders\n    // were marked for explicit hydration\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\n    let isRouteInitialized = (m: AgnosticDataRouteMatch) => {\n      // No loader, nothing to initialize\n      if (!m.route.loader) {\n        return true;\n      }\n      // Explicitly opting-in to running on hydration\n      if (\n        typeof m.route.loader === \"function\" &&\n        m.route.loader.hydrate === true\n      ) {\n        return false;\n      }\n      // Otherwise, initialized if hydrated with data or an error\n      return (\n        (loaderData && loaderData[m.route.id] !== undefined) ||\n        (errors && errors[m.route.id] !== undefined)\n      );\n    };\n\n    // If errors exist, don't consider routes below the boundary\n    if (errors) {\n      let idx = initialMatches.findIndex(\n        (m) => errors![m.route.id] !== undefined\n      );\n      initialized = initialMatches.slice(0, idx + 1).every(isRouteInitialized);\n    } else {\n      initialized = initialMatches.every(isRouteInitialized);\n    }\n  } else {\n    // Without partial hydration - we're initialized if we were provided any\n    // hydrationData - which is expected to be complete\n    initialized = init.hydrationData != null;\n  }\n\n  let router: Router;\n  let state: RouterState = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: (init.hydrationData && init.hydrationData.loaderData) || {},\n    actionData: (init.hydrationData && init.hydrationData.actionData) || null,\n    errors: (init.hydrationData && init.hydrationData.errors) || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map(),\n  };\n\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction: HistoryAction = HistoryAction.Pop;\n\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n\n  // AbortController for the active navigation\n  let pendingNavigationController: AbortController | null;\n\n  // Should the current navigation enable document.startViewTransition?\n  let pendingViewTransitionEnabled = false;\n\n  // Store applied view transitions so we can apply them on POP\n  let appliedViewTransitions: Map<string, Set<string>> = new Map<\n    string,\n    Set<string>\n  >();\n\n  // Cleanup function for persisting applied transitions to sessionStorage\n  let removePageHideEventListener: (() => void) | null = null;\n\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes: string[] = [];\n\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads: string[] = [];\n\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map<string, AbortController>();\n\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map<string, number>();\n\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set<string>();\n\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map<string, FetchLoadMatch>();\n\n  // Ref-count mounted fetchers so we know when it's ok to clean them up\n  let activeFetchers = new Map<string, number>();\n\n  // Fetchers that have requested a delete when using v7_fetcherPersist,\n  // they'll be officially removed after they return to idle\n  let deletedFetchers = new Set<string>();\n\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map<string, DeferredData>();\n\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map<string, BlockerFunction>();\n\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(\n      ({ action: historyAction, location, delta }) => {\n        // Ignore this event if it was just us resetting the URL from a\n        // blocked POP navigation\n        if (ignoreNextHistoryUpdate) {\n          ignoreNextHistoryUpdate = false;\n          return;\n        }\n\n        warning(\n          blockerFunctions.size === 0 || delta != null,\n          \"You are trying to use a blocker on a POP navigation to a location \" +\n            \"that was not created by @remix-run/router. This will fail silently in \" +\n            \"production. This can happen if you are navigating outside the router \" +\n            \"via `window.history.pushState`/`window.location.hash` instead of using \" +\n            \"router navigation APIs.  This can also happen if you are using \" +\n            \"createHashRouter and the user manually changes the URL.\"\n        );\n\n        let blockerKey = shouldBlockNavigation({\n          currentLocation: state.location,\n          nextLocation: location,\n          historyAction,\n        });\n\n        if (blockerKey && delta != null) {\n          // Restore the URL to match the current UI, but don't update router state\n          ignoreNextHistoryUpdate = true;\n          init.history.go(delta * -1);\n\n          // Put the blocker into a blocked state\n          updateBlocker(blockerKey, {\n            state: \"blocked\",\n            location,\n            proceed() {\n              updateBlocker(blockerKey!, {\n                state: \"proceeding\",\n                proceed: undefined,\n                reset: undefined,\n                location,\n              });\n              // Re-do the same POP navigation we just blocked\n              init.history.go(delta);\n            },\n            reset() {\n              let blockers = new Map(state.blockers);\n              blockers.set(blockerKey!, IDLE_BLOCKER);\n              updateState({ blockers });\n            },\n          });\n          return;\n        }\n\n        return startNavigation(historyAction, location);\n      }\n    );\n\n    if (isBrowser) {\n      // FIXME: This feels gross.  How can we cleanup the lines between\n      // scrollRestoration/appliedTransitions persistance?\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () =>\n        persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () =>\n        routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(HistoryAction.Pop, state.location, {\n        initialHydration: true,\n      });\n    }\n\n    return router;\n  }\n\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n\n  // Subscribe to state updates for the router\n  function subscribe(fn: RouterSubscriber) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n\n  // Update our state and notify the calling context of the change\n  function updateState(\n    newState: Partial<RouterState>,\n    opts: {\n      flushSync?: boolean;\n      viewTransitionOpts?: ViewTransitionOpts;\n    } = {}\n  ): void {\n    state = {\n      ...state,\n      ...newState,\n    };\n\n    // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n    // can be removed\n    let completedFetchers: string[] = [];\n    let deletedFetchersKeys: string[] = [];\n\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            // Unmounted from the UI and can be totally removed\n            deletedFetchersKeys.push(key);\n          } else {\n            // Returned to idle but still mounted in the UI, so semi-remains for\n            // revalidations and such\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n\n    // Iterate over a local copy so that if flushSync is used and we end up\n    // removing and adding a new subscriber due to the useCallback dependencies,\n    // we don't get ourselves into a loop calling the new subscriber immediately\n    [...subscribers].forEach((subscriber) =>\n      subscriber(state, {\n        deletedFetchers: deletedFetchersKeys,\n        unstable_viewTransitionOpts: opts.viewTransitionOpts,\n        unstable_flushSync: opts.flushSync === true,\n      })\n    );\n\n    // Remove idle fetchers from state since we only care about in-flight fetchers.\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach((key) => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach((key) => deleteFetcher(key));\n    }\n  }\n\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(\n    location: Location,\n    newState: Partial<Omit<RouterState, \"action\" | \"location\" | \"navigation\">>,\n    { flushSync }: { flushSync?: boolean } = {}\n  ): void {\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload =\n      state.actionData != null &&\n      state.navigation.formMethod != null &&\n      isMutationMethod(state.navigation.formMethod) &&\n      state.navigation.state === \"loading\" &&\n      location.state?._isRedirect !== true;\n\n    let actionData: RouteData | null;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData\n      ? mergeLoaderData(\n          state.loaderData,\n          newState.loaderData,\n          newState.matches || [],\n          newState.errors\n        )\n      : state.loaderData;\n\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset =\n      pendingPreventScrollReset === true ||\n      (state.navigation.formMethod != null &&\n        isMutationMethod(state.navigation.formMethod) &&\n        location.state?._isRedirect !== true);\n\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n\n    if (isUninterruptedRevalidation) {\n      // If this was an uninterrupted revalidation then do not touch history\n    } else if (pendingAction === HistoryAction.Pop) {\n      // Do nothing for POP - URL has already been updated\n    } else if (pendingAction === HistoryAction.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === HistoryAction.Replace) {\n      init.history.replace(location, location.state);\n    }\n\n    let viewTransitionOpts: ViewTransitionOpts | undefined;\n\n    // On POP, enable transitions if they were enabled on the original navigation\n    if (pendingAction === HistoryAction.Pop) {\n      // Forward takes precedence so they behave like the original navigation\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location,\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        // If we don't have a previous forward nav, assume we're popping back to\n        // the new location and enable if that location previously enabled\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location,\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      // Store the applied transition on PUSH/REPLACE\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = new Set<string>([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location,\n      };\n    }\n\n    updateState(\n      {\n        ...newState, // matches, errors, fetchers go through as-is\n        actionData,\n        loaderData,\n        historyAction: pendingAction,\n        location,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        revalidation: \"idle\",\n        restoreScrollPosition: getSavedScrollPosition(\n          location,\n          newState.matches || state.matches\n        ),\n        preventScrollReset,\n        blockers,\n      },\n      {\n        viewTransitionOpts,\n        flushSync: flushSync === true,\n      }\n    );\n\n    // Reset stateful navigation vars\n    pendingAction = HistoryAction.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(\n    to: number | To | null,\n    opts?: RouterNavigateOptions\n  ): Promise<void> {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      future.v7_prependBasename,\n      to,\n      future.v7_relativeSplatPath,\n      opts?.fromRouteId,\n      opts?.relative\n    );\n    let { path, submission, error } = normalizeNavigateOptions(\n      future.v7_normalizeFormMethod,\n      false,\n      normalizedPath,\n      opts\n    );\n\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = {\n      ...nextLocation,\n      ...init.history.encodeLocation(nextLocation),\n    };\n\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n\n    let historyAction = HistoryAction.Push;\n\n    if (userReplace === true) {\n      historyAction = HistoryAction.Replace;\n    } else if (userReplace === false) {\n      // no-op\n    } else if (\n      submission != null &&\n      isMutationMethod(submission.formMethod) &&\n      submission.formAction === state.location.pathname + state.location.search\n    ) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = HistoryAction.Replace;\n    }\n\n    let preventScrollReset =\n      opts && \"preventScrollReset\" in opts\n        ? opts.preventScrollReset === true\n        : undefined;\n\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction,\n    });\n\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey!, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation,\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey!, IDLE_BLOCKER);\n          updateState({ blockers });\n        },\n      });\n      return;\n    }\n\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.unstable_viewTransition,\n      flushSync,\n    });\n  }\n\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({ revalidation: \"loading\" });\n\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true,\n      });\n      return;\n    }\n\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(\n      pendingAction || state.historyAction,\n      state.navigation.location,\n      { overrideNavigation: state.navigation }\n    );\n  }\n\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(\n    historyAction: HistoryAction,\n    location: Location,\n    opts?: {\n      initialHydration?: boolean;\n      submission?: Submission;\n      fetcherSubmission?: Submission;\n      overrideNavigation?: Navigation;\n      pendingError?: ErrorResponseImpl;\n      startUninterruptedRevalidation?: boolean;\n      preventScrollReset?: boolean;\n      replace?: boolean;\n      enableViewTransition?: boolean;\n      flushSync?: boolean;\n    }\n  ): Promise<void> {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation =\n      (opts && opts.startUninterruptedRevalidation) === true;\n\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(\n        location,\n        {\n          matches: notFoundMatches,\n          loaderData: {},\n          errors: {\n            [route.id]: error,\n          },\n        },\n        { flushSync }\n      );\n      return;\n    }\n\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (\n      state.initialized &&\n      !isRevalidationRequired &&\n      isHashChangeOnly(state.location, location) &&\n      !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))\n    ) {\n      completeNavigation(location, { matches }, { flushSync });\n      return;\n    }\n\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(\n      init.history,\n      location,\n      pendingNavigationController.signal,\n      opts && opts.submission\n    );\n    let pendingActionResult: PendingActionResult | undefined;\n\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingActionResult = [\n        findNearestBoundary(matches).route.id,\n        { type: ResultType.error, error: opts.pendingError },\n      ];\n    } else if (\n      opts &&\n      opts.submission &&\n      isMutationMethod(opts.submission.formMethod)\n    ) {\n      // Call action if we received an action submission\n      let actionResult = await handleAction(\n        request,\n        location,\n        opts.submission,\n        matches,\n        { replace: opts.replace, flushSync }\n      );\n\n      if (actionResult.shortCircuited) {\n        return;\n      }\n\n      pendingActionResult = actionResult.pendingActionResult;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n\n      // Create a GET request for the loaders\n      request = createClientSideRequest(\n        init.history,\n        request.url,\n        request.signal\n      );\n    }\n\n    // Call loaders\n    let { shortCircuited, loaderData, errors } = await handleLoaders(\n      request,\n      location,\n      matches,\n      loadingNavigation,\n      opts && opts.submission,\n      opts && opts.fetcherSubmission,\n      opts && opts.replace,\n      opts && opts.initialHydration === true,\n      flushSync,\n      pendingActionResult\n    );\n\n    if (shortCircuited) {\n      return;\n    }\n\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n\n    completeNavigation(location, {\n      matches,\n      ...getActionDataForCommit(pendingActionResult),\n      loaderData,\n      errors,\n    });\n  }\n\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(\n    request: Request,\n    location: Location,\n    submission: Submission,\n    matches: AgnosticDataRouteMatch[],\n    opts: { replace?: boolean; flushSync?: boolean } = {}\n  ): Promise<HandleActionResult> {\n    interruptActiveLoads();\n\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({ navigation }, { flushSync: opts.flushSync === true });\n\n    // Call our action and get the result\n    let result: DataResult;\n    let actionMatch = getTargetMatch(matches, location);\n\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id,\n        }),\n      };\n    } else {\n      let results = await callDataStrategy(\n        \"action\",\n        request,\n        [actionMatch],\n        matches\n      );\n      result = results[0];\n\n      if (request.signal.aborted) {\n        return { shortCircuited: true };\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      let replace: boolean;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        let location = normalizeRedirectLocation(\n          result.response.headers.get(\"Location\")!,\n          new URL(request.url),\n          basename\n        );\n        replace = location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(request, result, {\n        submission,\n        replace,\n      });\n      return { shortCircuited: true };\n    }\n\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, { type: \"defer-action\" });\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = HistoryAction.Push;\n      }\n\n      return {\n        pendingActionResult: [boundaryMatch.route.id, result],\n      };\n    }\n\n    return {\n      pendingActionResult: [actionMatch.route.id, result],\n    };\n  }\n\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    overrideNavigation?: Navigation,\n    submission?: Submission,\n    fetcherSubmission?: Submission,\n    replace?: boolean,\n    initialHydration?: boolean,\n    flushSync?: boolean,\n    pendingActionResult?: PendingActionResult\n  ): Promise<HandleLoadersResult> {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation =\n      overrideNavigation || getLoadingNavigation(location, submission);\n\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission =\n      submission ||\n      fetcherSubmission ||\n      getSubmissionFromNavigation(loadingNavigation);\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      activeSubmission,\n      location,\n      future.v7_partialHydration && initialHydration === true,\n      future.unstable_skipActionErrorRevalidation,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      deletedFetchers,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      pendingActionResult\n    );\n\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(\n      (routeId) =>\n        !(matches && matches.some((m) => m.route.id === routeId)) ||\n        (matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId))\n    );\n\n    pendingNavigationLoadId = ++incrementingLoadId;\n\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(\n        location,\n        {\n          matches,\n          loaderData: {},\n          // Commit pending error if we're short circuiting\n          errors:\n            pendingActionResult && isErrorResult(pendingActionResult[1])\n              ? { [pendingActionResult[0]]: pendingActionResult[1].error }\n              : null,\n          ...getActionDataForCommit(pendingActionResult),\n          ...(updatedFetchers ? { fetchers: new Map(state.fetchers) } : {}),\n        },\n        { flushSync }\n      );\n      return { shortCircuited: true };\n    }\n\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    // If we have partialHydration enabled, then don't update the state for the\n    // initial data load since it's not a \"navigation\"\n    if (\n      !isUninterruptedRevalidation &&\n      (!future.v7_partialHydration || !initialHydration)\n    ) {\n      revalidatingFetchers.forEach((rf) => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(\n          undefined,\n          fetcher ? fetcher.data : undefined\n        );\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n\n      let actionData: Record<string, RouteData> | null | undefined;\n      if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\n        // This is cast to `any` currently because `RouteData`uses any and it\n        // would be a breaking change to use any.\n        // TODO: v7 - change `RouteData` to use `unknown` instead of `any`\n        actionData = {\n          [pendingActionResult[0]]: pendingActionResult[1].data as any,\n        };\n      } else if (state.actionData) {\n        if (Object.keys(state.actionData).length === 0) {\n          actionData = null;\n        } else {\n          actionData = state.actionData;\n        }\n      }\n\n      updateState(\n        {\n          navigation: loadingNavigation,\n          ...(actionData !== undefined ? { actionData } : {}),\n          ...(revalidatingFetchers.length > 0\n            ? { fetchers: new Map(state.fetchers) }\n            : {}),\n        },\n        {\n          flushSync,\n        }\n      );\n    }\n\n    revalidatingFetchers.forEach((rf) => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () =>\n      revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n\n    let { loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        request\n      );\n\n    if (request.signal.aborted) {\n      return { shortCircuited: true };\n    }\n\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect([...loaderResults, ...fetcherResults]);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey =\n          revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(request, redirect.result, {\n        replace,\n      });\n      return { shortCircuited: true };\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      matchesToLoad,\n      loaderResults,\n      pendingActionResult,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe((aborted) => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n\n    // During partial hydration, preserve SSR errors for routes that don't re-run\n    if (future.v7_partialHydration && initialHydration && state.errors) {\n      Object.entries(state.errors)\n        .filter(([id]) => !matchesToLoad.some((m) => m.route.id === id))\n        .forEach(([routeId, error]) => {\n          errors = Object.assign(errors || {}, { [routeId]: error });\n        });\n    }\n\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers =\n      updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n\n    return {\n      loaderData,\n      errors,\n      ...(shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}),\n    };\n  }\n\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(\n    key: string,\n    routeId: string,\n    href: string | null,\n    opts?: RouterFetchOptions\n  ) {\n    if (isServer) {\n      throw new Error(\n        \"router.fetch() was called during the server render, but it shouldn't be. \" +\n          \"You are likely calling a useFetcher() method in the body of your component. \" +\n          \"Try moving it to a useEffect or a callback.\"\n      );\n    }\n\n    if (fetchControllers.has(key)) abortFetcher(key);\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      future.v7_prependBasename,\n      href,\n      future.v7_relativeSplatPath,\n      routeId,\n      opts?.relative\n    );\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n\n    if (!matches) {\n      setFetcherError(\n        key,\n        routeId,\n        getInternalRouterError(404, { pathname: normalizedPath }),\n        { flushSync }\n      );\n      return;\n    }\n\n    let { path, submission, error } = normalizeNavigateOptions(\n      future.v7_normalizeFormMethod,\n      true,\n      normalizedPath,\n      opts\n    );\n\n    if (error) {\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n\n    let match = getTargetMatch(matches, path);\n\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(\n        key,\n        routeId,\n        path,\n        match,\n        matches,\n        flushSync,\n        submission\n      );\n      return;\n    }\n\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, { routeId, path });\n    handleFetcherLoader(\n      key,\n      routeId,\n      path,\n      match,\n      matches,\n      flushSync,\n      submission\n    );\n  }\n\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    requestMatches: AgnosticDataRouteMatch[],\n    flushSync: boolean,\n    submission: Submission\n  ) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId,\n      });\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync,\n    });\n\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal,\n      submission\n    );\n    fetchControllers.set(key, abortController);\n\n    let originatingLoadId = incrementingLoadId;\n    let actionResults = await callDataStrategy(\n      \"action\",\n      fetchRequest,\n      [match],\n      requestMatches\n    );\n    let actionResult = actionResults[0];\n\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n\n    // When using v7_fetcherPersist, we don't want errors bubbling up to the UI\n    // or redirects processed for unmounted fetchers so we just revert them to\n    // idle\n    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {\n      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      }\n      // Let SuccessResult's fall through for revalidation\n    } else {\n      if (isRedirectResult(actionResult)) {\n        fetchControllers.delete(key);\n        if (pendingNavigationLoadId > originatingLoadId) {\n          // A new navigation was kicked off after our action started, so that\n          // should take precedence over this redirect navigation.  We already\n          // set isRevalidationRequired so all loaders for the new route should\n          // fire unless opted out via shouldRevalidate\n          updateFetcherState(key, getDoneFetcher(undefined));\n          return;\n        } else {\n          fetchRedirectIds.add(key);\n          updateFetcherState(key, getLoadingFetcher(submission));\n          return startRedirectNavigation(fetchRequest, actionResult, {\n            fetcherSubmission: submission,\n          });\n        }\n      }\n\n      // Process any non-redirect errors thrown\n      if (isErrorResult(actionResult)) {\n        setFetcherError(key, routeId, actionResult.error);\n        return;\n      }\n    }\n\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, { type: \"defer-action\" });\n    }\n\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(\n      init.history,\n      nextLocation,\n      abortController.signal\n    );\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches =\n      state.navigation.state !== \"idle\"\n        ? matchRoutes(routesToUse, state.navigation.location, basename)\n        : state.matches;\n\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      false,\n      future.unstable_skipActionErrorRevalidation,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      deletedFetchers,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      [match.route.id, actionResult]\n    );\n\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers\n      .filter((rf) => rf.key !== key)\n      .forEach((rf) => {\n        let staleKey = rf.key;\n        let existingFetcher = state.fetchers.get(staleKey);\n        let revalidatingFetcher = getLoadingFetcher(\n          undefined,\n          existingFetcher ? existingFetcher.data : undefined\n        );\n        state.fetchers.set(staleKey, revalidatingFetcher);\n        if (fetchControllers.has(staleKey)) {\n          abortFetcher(staleKey);\n        }\n        if (rf.controller) {\n          fetchControllers.set(staleKey, rf.controller);\n        }\n      });\n\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    let abortPendingFetchRevalidations = () =>\n      revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n\n    abortController.signal.addEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n\n    let { loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        revalidationRequest\n      );\n\n    if (abortController.signal.aborted) {\n      return;\n    }\n\n    abortController.signal.removeEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n\n    let redirect = findRedirect([...loaderResults, ...fetcherResults]);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey =\n          revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(revalidationRequest, redirect.result);\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      state.matches,\n      matchesToLoad,\n      loaderResults,\n      undefined,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n\n    abortStaleFetchLoads(loadId);\n\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (\n      state.navigation.state === \"loading\" &&\n      loadId > pendingNavigationLoadId\n    ) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers),\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(\n          state.loaderData,\n          loaderData,\n          matches,\n          errors\n        ),\n        fetchers: new Map(state.fetchers),\n      });\n      isRevalidationRequired = false;\n    }\n  }\n\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    matches: AgnosticDataRouteMatch[],\n    flushSync: boolean,\n    submission?: Submission\n  ) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(\n      key,\n      getLoadingFetcher(\n        submission,\n        existingFetcher ? existingFetcher.data : undefined\n      ),\n      { flushSync }\n    );\n\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal\n    );\n    fetchControllers.set(key, abortController);\n\n    let originatingLoadId = incrementingLoadId;\n    let results = await callDataStrategy(\n      \"loader\",\n      fetchRequest,\n      [match],\n      matches\n    );\n    let result = results[0];\n\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result =\n        (await resolveDeferredData(result, fetchRequest.signal, true)) ||\n        result;\n    }\n\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n\n    // We don't want errors bubbling up or redirects followed for unmounted\n    // fetchers, so short circuit here if it was removed from the UI\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(fetchRequest, result);\n        return;\n      }\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n\n    // Put the fetcher back into an idle state\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(\n    request: Request,\n    redirect: RedirectResult,\n    {\n      submission,\n      fetcherSubmission,\n      replace,\n    }: {\n      submission?: Submission;\n      fetcherSubmission?: Submission;\n      replace?: boolean;\n    } = {}\n  ) {\n    if (redirect.response.headers.has(\"X-Remix-Revalidate\")) {\n      isRevalidationRequired = true;\n    }\n\n    let location = redirect.response.headers.get(\"Location\");\n    invariant(location, \"Expected a Location header on the redirect Response\");\n    location = normalizeRedirectLocation(\n      location,\n      new URL(request.url),\n      basename\n    );\n    let redirectLocation = createLocation(state.location, location, {\n      _isRedirect: true,\n    });\n\n    if (isBrowser) {\n      let isDocumentReload = false;\n\n      if (redirect.response.headers.has(\"X-Remix-Reload-Document\")) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(location)) {\n        const url = init.history.createURL(location);\n        isDocumentReload =\n          // Hard reload if it's an absolute URL to a new origin\n          url.origin !== routerWindow.location.origin ||\n          // Hard reload if it's an absolute URL that does not match our basename\n          stripBasename(url.pathname, basename) == null;\n      }\n\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(location);\n        } else {\n          routerWindow.location.assign(location);\n        }\n        return;\n      }\n    }\n\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n\n    let redirectHistoryAction =\n      replace === true ? HistoryAction.Replace : HistoryAction.Push;\n\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let { formMethod, formAction, formEncType } = state.navigation;\n    if (\n      !submission &&\n      !fetcherSubmission &&\n      formMethod &&\n      formAction &&\n      formEncType\n    ) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (\n      redirectPreserveMethodStatusCodes.has(redirect.response.status) &&\n      activeSubmission &&\n      isMutationMethod(activeSubmission.formMethod)\n    ) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: {\n          ...activeSubmission,\n          formAction: location,\n        },\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(\n        redirectLocation,\n        submission\n      );\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    }\n  }\n\n  // Utility wrapper for calling dataStrategy client-side without having to\n  // pass around the manifest, mapRouteProperties, etc.\n  async function callDataStrategy(\n    type: \"loader\" | \"action\",\n    request: Request,\n    matchesToLoad: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[]\n  ): Promise<DataResult[]> {\n    try {\n      let results = await callDataStrategyImpl(\n        dataStrategyImpl,\n        type,\n        request,\n        matchesToLoad,\n        matches,\n        manifest,\n        mapRouteProperties\n      );\n\n      return await Promise.all(\n        results.map((result, i) => {\n          if (isRedirectHandlerResult(result)) {\n            let response = result.result as Response;\n            return {\n              type: ResultType.redirect,\n              response: normalizeRelativeRoutingRedirectResponse(\n                response,\n                request,\n                matchesToLoad[i].route.id,\n                matches,\n                basename,\n                future.v7_relativeSplatPath\n              ),\n            };\n          }\n\n          return convertHandlerResultToDataResult(result);\n        })\n      );\n    } catch (e) {\n      // If the outer dataStrategy method throws, just return the error for all\n      // matches - and it'll naturally bubble to the root\n      return matchesToLoad.map(() => ({\n        type: ResultType.error,\n        error: e,\n      }));\n    }\n  }\n\n  async function callLoadersAndMaybeResolveData(\n    currentMatches: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[],\n    matchesToLoad: AgnosticDataRouteMatch[],\n    fetchersToLoad: RevalidatingFetcher[],\n    request: Request\n  ) {\n    let [loaderResults, ...fetcherResults] = await Promise.all([\n      matchesToLoad.length\n        ? callDataStrategy(\"loader\", request, matchesToLoad, matches)\n        : [],\n      ...fetchersToLoad.map((f) => {\n        if (f.matches && f.match && f.controller) {\n          let fetcherRequest = createClientSideRequest(\n            init.history,\n            f.path,\n            f.controller.signal\n          );\n          return callDataStrategy(\n            \"loader\",\n            fetcherRequest,\n            [f.match],\n            f.matches\n          ).then((r) => r[0]);\n        } else {\n          return Promise.resolve<DataResult>({\n            type: ResultType.error,\n            error: getInternalRouterError(404, {\n              pathname: f.path,\n            }),\n          });\n        }\n      }),\n    ]);\n\n    await Promise.all([\n      resolveDeferredResults(\n        currentMatches,\n        matchesToLoad,\n        loaderResults,\n        loaderResults.map(() => request.signal),\n        false,\n        state.loaderData\n      ),\n      resolveDeferredResults(\n        currentMatches,\n        fetchersToLoad.map((f) => f.match),\n        fetcherResults,\n        fetchersToLoad.map((f) => (f.controller ? f.controller.signal : null)),\n        true\n      ),\n    ]);\n\n    return {\n      loaderResults,\n      fetcherResults,\n    };\n  }\n\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n\n  function updateFetcherState(\n    key: string,\n    fetcher: Fetcher,\n    opts: { flushSync?: boolean } = {}\n  ) {\n    state.fetchers.set(key, fetcher);\n    updateState(\n      { fetchers: new Map(state.fetchers) },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n\n  function setFetcherError(\n    key: string,\n    routeId: string,\n    error: any,\n    opts: { flushSync?: boolean } = {}\n  ) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState(\n      {\n        errors: {\n          [boundaryMatch.route.id]: error,\n        },\n        fetchers: new Map(state.fetchers),\n      },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n\n  function getFetcher<TData = any>(key: string): Fetcher<TData> {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      // If this fetcher was previously marked for deletion, unmark it since we\n      // have a new instance\n      if (deletedFetchers.has(key)) {\n        deletedFetchers.delete(key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n\n  function deleteFetcher(key: string): void {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (\n      fetchControllers.has(key) &&\n      !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))\n    ) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    deletedFetchers.delete(key);\n    state.fetchers.delete(key);\n  }\n\n  function deleteFetcherAndUpdateState(key: string): void {\n    if (future.v7_fetcherPersist) {\n      let count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers.delete(key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({ fetchers: new Map(state.fetchers) });\n  }\n\n  function abortFetcher(key: string) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, `Expected fetch controller: ${key}`);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n\n  function markFetchersDone(keys: string[]) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  function markFetchRedirectsDone(): boolean {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n\n  function abortStaleFetchLoads(landedId: number): boolean {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n\n  function getBlocker(key: string, fn: BlockerFunction) {\n    let blocker: Blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n\n    return blocker;\n  }\n\n  function deleteBlocker(key: string) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key: string, newBlocker: Blocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(\n      (blocker.state === \"unblocked\" && newBlocker.state === \"blocked\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"blocked\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"proceeding\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"unblocked\") ||\n        (blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\"),\n      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`\n    );\n\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({ blockers });\n  }\n\n  function shouldBlockNavigation({\n    currentLocation,\n    nextLocation,\n    historyAction,\n  }: {\n    currentLocation: Location;\n    nextLocation: Location;\n    historyAction: HistoryAction;\n  }): string | undefined {\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({ currentLocation, nextLocation, historyAction })) {\n      return blockerKey;\n    }\n  }\n\n  function cancelActiveDeferreds(\n    predicate?: (routeId: string) => boolean\n  ): string[] {\n    let cancelledRouteIds: string[] = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(\n    positions: Record<string, number>,\n    getPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({ restoreScrollPosition: y });\n      }\n    }\n\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n\n  function getScrollKey(location: Location, matches: AgnosticDataRouteMatch[]) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(\n        location,\n        matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))\n      );\n      return key || location.key;\n    }\n    return location.key;\n  }\n\n  function saveScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): void {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n\n  function getSavedScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): number | null {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n\n  function _internalSetRoutes(newRoutes: AgnosticDataRouteObject[]) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(\n      newRoutes,\n      mapRouteProperties,\n      undefined,\n      manifest\n    );\n  }\n\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to: To) => init.history.createHref(to),\n    encodeLocation: (to: To) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes,\n  };\n\n  return router;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\n\nexport const UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\n\n/**\n * Future flags to toggle new feature behavior\n */\nexport interface StaticHandlerFutureConfig {\n  v7_relativeSplatPath: boolean;\n  v7_throwAbortReason: boolean;\n}\n\nexport interface CreateStaticHandlerOptions {\n  basename?: string;\n  /**\n   * @deprecated Use `mapRouteProperties` instead\n   */\n  detectErrorBoundary?: DetectErrorBoundaryFunction;\n  mapRouteProperties?: MapRoutePropertiesFunction;\n  future?: Partial<StaticHandlerFutureConfig>;\n}\n\nexport function createStaticHandler(\n  routes: AgnosticRouteObject[],\n  opts?: CreateStaticHandlerOptions\n): StaticHandler {\n  invariant(\n    routes.length > 0,\n    \"You must provide a non-empty routes array to createStaticHandler\"\n  );\n\n  let manifest: RouteManifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties: MapRoutePropertiesFunction;\n  if (opts?.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts?.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route),\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Config driven behavior flags\n  let future: StaticHandlerFutureConfig = {\n    v7_relativeSplatPath: false,\n    v7_throwAbortReason: false,\n    ...(opts ? opts.future : null),\n  };\n\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties,\n    undefined,\n    manifest\n  );\n\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   *\n   * - `opts.requestContext` is an optional server context that will be passed\n   *   to actions/loaders in the `context` parameter\n   * - `opts.skipLoaderErrorBubbling` is an optional parameter that will prevent\n   *   the bubbling of errors which allows single-fetch-type implementations\n   *   where the client will handle the bubbling and we may need to return data\n   *   for the handling route\n   */\n  async function query(\n    request: Request,\n    {\n      requestContext,\n      skipLoaderErrorBubbling,\n      unstable_dataStrategy,\n    }: {\n      requestContext?: unknown;\n      skipLoaderErrorBubbling?: boolean;\n      unstable_dataStrategy?: DataStrategyFunction;\n    } = {}\n  ): Promise<StaticHandlerContext | Response> {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, { method });\n      let { matches: methodNotAllowedMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      unstable_dataStrategy || null,\n      skipLoaderErrorBubbling === true,\n      null\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return { location, basename, ...result };\n  }\n\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   *\n   * - `opts.routeId` allows you to specify the specific route handler to call.\n   *   If not provided the handler will determine the proper route by matching\n   *   against `request.url`\n   * - `opts.requestContext` is an optional server context that will be passed\n   *    to actions/loaders in the `context` parameter\n   */\n  async function queryRoute(\n    request: Request,\n    {\n      routeId,\n      requestContext,\n      unstable_dataStrategy,\n    }: {\n      requestContext?: unknown;\n      routeId?: string;\n      unstable_dataStrategy?: DataStrategyFunction;\n    } = {}\n  ): Promise<any> {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, { method });\n    } else if (!matches) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let match = routeId\n      ? matches.find((m) => m.route.id === routeId)\n      : getTargetMatch(matches, location);\n\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId,\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      unstable_dataStrategy || null,\n      false,\n      match\n    );\n\n    if (isResponse(result)) {\n      return result;\n    }\n\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n\n    if (result.loaderData) {\n      let data = Object.values(result.loaderData)[0];\n      if (result.activeDeferreds?.[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n\n    return undefined;\n  }\n\n  async function queryImpl(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    unstable_dataStrategy: DataStrategyFunction | null,\n    skipLoaderErrorBubbling: boolean,\n    routeMatch: AgnosticDataRouteMatch | null\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    invariant(\n      request.signal,\n      \"query()/queryRoute() requests must contain an AbortController signal\"\n    );\n\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(\n          request,\n          matches,\n          routeMatch || getTargetMatch(matches, location),\n          requestContext,\n          unstable_dataStrategy,\n          skipLoaderErrorBubbling,\n          routeMatch != null\n        );\n        return result;\n      }\n\n      let result = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        unstable_dataStrategy,\n        skipLoaderErrorBubbling,\n        routeMatch\n      );\n      return isResponse(result)\n        ? result\n        : {\n            ...result,\n            actionData: null,\n            actionHeaders: {},\n          };\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction for a\n      // `queryRoute` call, we throw the `HandlerResult` to bail out early\n      // and then return or throw the raw Response here accordingly\n      if (isHandlerResult(e) && isResponse(e.result)) {\n        if (e.type === ResultType.error) {\n          throw e.result;\n        }\n        return e.result;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  async function submit(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    actionMatch: AgnosticDataRouteMatch,\n    requestContext: unknown,\n    unstable_dataStrategy: DataStrategyFunction | null,\n    skipLoaderErrorBubbling: boolean,\n    isRouteRequest: boolean\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    let result: DataResult;\n\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id,\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    } else {\n      let results = await callDataStrategy(\n        \"action\",\n        request,\n        [actionMatch],\n        matches,\n        isRouteRequest,\n        requestContext,\n        unstable_dataStrategy\n      );\n      result = results[0];\n\n      if (request.signal.aborted) {\n        throwStaticHandlerAbortedError(request, isRouteRequest, future);\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.response.status,\n        headers: {\n          Location: result.response.headers.get(\"Location\")!,\n        },\n      });\n    }\n\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, { type: \"defer-action\" });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    }\n\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: { [actionMatch.route.id]: result.data },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal,\n    });\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = skipLoaderErrorBubbling\n        ? actionMatch\n        : findNearestBoundary(matches, actionMatch.route.id);\n\n      let context = await loadRouteData(\n        loaderRequest,\n        matches,\n        requestContext,\n        unstable_dataStrategy,\n        skipLoaderErrorBubbling,\n        null,\n        [boundaryMatch.route.id, result]\n      );\n\n      // action status codes take precedence over loader status codes\n      return {\n        ...context,\n        statusCode: isRouteErrorResponse(result.error)\n          ? result.error.status\n          : result.statusCode != null\n          ? result.statusCode\n          : 500,\n        actionData: null,\n        actionHeaders: {\n          ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n        },\n      };\n    }\n\n    let context = await loadRouteData(\n      loaderRequest,\n      matches,\n      requestContext,\n      unstable_dataStrategy,\n      skipLoaderErrorBubbling,\n      null\n    );\n\n    return {\n      ...context,\n      actionData: {\n        [actionMatch.route.id]: result.data,\n      },\n      // action status codes take precedence over loader status codes\n      ...(result.statusCode ? { statusCode: result.statusCode } : {}),\n      actionHeaders: result.headers\n        ? { [actionMatch.route.id]: result.headers }\n        : {},\n    };\n  }\n\n  async function loadRouteData(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    unstable_dataStrategy: DataStrategyFunction | null,\n    skipLoaderErrorBubbling: boolean,\n    routeMatch: AgnosticDataRouteMatch | null,\n    pendingActionResult?: PendingActionResult\n  ): Promise<\n    | Omit<\n        StaticHandlerContext,\n        \"location\" | \"basename\" | \"actionData\" | \"actionHeaders\"\n      >\n    | Response\n  > {\n    let isRouteRequest = routeMatch != null;\n\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (\n      isRouteRequest &&\n      !routeMatch?.route.loader &&\n      !routeMatch?.route.lazy\n    ) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch?.route.id,\n      });\n    }\n\n    let requestMatches = routeMatch\n      ? [routeMatch]\n      : pendingActionResult && isErrorResult(pendingActionResult[1])\n      ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0])\n      : matches;\n    let matchesToLoad = requestMatches.filter(\n      (m) => m.route.loader || m.route.lazy\n    );\n\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce(\n          (acc, m) => Object.assign(acc, { [m.route.id]: null }),\n          {}\n        ),\n        errors:\n          pendingActionResult && isErrorResult(pendingActionResult[1])\n            ? {\n                [pendingActionResult[0]]: pendingActionResult[1].error,\n              }\n            : null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    let results = await callDataStrategy(\n      \"loader\",\n      request,\n      matchesToLoad,\n      matches,\n      isRouteRequest,\n      requestContext,\n      unstable_dataStrategy\n    );\n\n    if (request.signal.aborted) {\n      throwStaticHandlerAbortedError(request, isRouteRequest, future);\n    }\n\n    // Process and commit output from loaders\n    let activeDeferreds = new Map<string, DeferredData>();\n    let context = processRouteLoaderData(\n      matches,\n      matchesToLoad,\n      results,\n      pendingActionResult,\n      activeDeferreds,\n      skipLoaderErrorBubbling\n    );\n\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set<string>(\n      matchesToLoad.map((match) => match.route.id)\n    );\n    matches.forEach((match) => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n\n    return {\n      ...context,\n      matches,\n      activeDeferreds:\n        activeDeferreds.size > 0\n          ? Object.fromEntries(activeDeferreds.entries())\n          : null,\n    };\n  }\n\n  // Utility wrapper for calling dataStrategy server-side without having to\n  // pass around the manifest, mapRouteProperties, etc.\n  async function callDataStrategy(\n    type: \"loader\" | \"action\",\n    request: Request,\n    matchesToLoad: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[],\n    isRouteRequest: boolean,\n    requestContext: unknown,\n    unstable_dataStrategy: DataStrategyFunction | null\n  ): Promise<DataResult[]> {\n    let results = await callDataStrategyImpl(\n      unstable_dataStrategy || defaultDataStrategy,\n      type,\n      request,\n      matchesToLoad,\n      matches,\n      manifest,\n      mapRouteProperties,\n      requestContext\n    );\n\n    return await Promise.all(\n      results.map((result, i) => {\n        if (isRedirectHandlerResult(result)) {\n          let response = result.result as Response;\n          // Throw redirects and let the server handle them with an HTTP redirect\n          throw normalizeRelativeRoutingRedirectResponse(\n            response,\n            request,\n            matchesToLoad[i].route.id,\n            matches,\n            basename,\n            future.v7_relativeSplatPath\n          );\n        }\n        if (isResponse(result.result) && isRouteRequest) {\n          // For SSR single-route requests, we want to hand Responses back\n          // directly without unwrapping\n          throw result;\n        }\n\n        return convertHandlerResultToDataResult(result);\n      })\n    );\n  }\n\n  return {\n    dataRoutes,\n    query,\n    queryRoute,\n  };\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nexport function getStaticContextFromError(\n  routes: AgnosticDataRouteObject[],\n  context: StaticHandlerContext,\n  error: any\n) {\n  let newContext: StaticHandlerContext = {\n    ...context,\n    statusCode: isRouteErrorResponse(error) ? error.status : 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error,\n    },\n  };\n  return newContext;\n}\n\nfunction throwStaticHandlerAbortedError(\n  request: Request,\n  isRouteRequest: boolean,\n  future: StaticHandlerFutureConfig\n) {\n  if (future.v7_throwAbortReason && request.signal.reason !== undefined) {\n    throw request.signal.reason;\n  }\n\n  let method = isRouteRequest ? \"queryRoute\" : \"query\";\n  throw new Error(`${method}() call aborted: ${request.method} ${request.url}`);\n}\n\nfunction isSubmissionNavigation(\n  opts: BaseNavigateOrFetchOptions\n): opts is SubmissionNavigateOptions {\n  return (\n    opts != null &&\n    ((\"formData\" in opts && opts.formData != null) ||\n      (\"body\" in opts && opts.body !== undefined))\n  );\n}\n\nfunction normalizeTo(\n  location: Path,\n  matches: AgnosticDataRouteMatch[],\n  basename: string,\n  prependBasename: boolean,\n  to: To | null,\n  v7_relativeSplatPath: boolean,\n  fromRouteId?: string,\n  relative?: RelativeRoutingType\n) {\n  let contextualMatches: AgnosticDataRouteMatch[];\n  let activeRouteMatch: AgnosticDataRouteMatch | undefined;\n  if (fromRouteId) {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n\n  // Resolve the relative path\n  let path = resolveTo(\n    to ? to : \".\",\n    getResolveToMatches(contextualMatches, v7_relativeSplatPath),\n    stripBasename(location.pathname, basename) || location.pathname,\n    relative === \"path\"\n  );\n\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n\n  // Add an ?index param for matched index routes if we don't already have one\n  if (\n    (to == null || to === \"\" || to === \".\") &&\n    activeRouteMatch &&\n    activeRouteMatch.route.index &&\n    !hasNakedIndexQuery(path.search)\n  ) {\n    path.search = path.search\n      ? path.search.replace(/^\\?/, \"?index&\")\n      : \"?index\";\n  }\n\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname =\n      path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n\n  return createPath(path);\n}\n\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(\n  normalizeFormMethod: boolean,\n  isFetcher: boolean,\n  path: string,\n  opts?: BaseNavigateOrFetchOptions\n): {\n  path: string;\n  submission?: Submission;\n  error?: ErrorResponseImpl;\n} {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return { path };\n  }\n\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, { method: opts.formMethod }),\n    };\n  }\n\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, { type: \"invalid-body\" }),\n  });\n\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod\n    ? (rawFormMethod.toUpperCase() as V7_FormMethod)\n    : (rawFormMethod.toLowerCase() as FormMethod);\n  let formAction = stripHashFromPath(path);\n\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n\n      let text =\n        typeof opts.body === \"string\"\n          ? opts.body\n          : opts.body instanceof FormData ||\n            opts.body instanceof URLSearchParams\n          ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce(\n              (acc, [name, value]) => `${acc}${name}=${value}\\n`,\n              \"\"\n            )\n          : String(opts.body);\n\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text,\n        },\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n\n      try {\n        let json =\n          typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined,\n          },\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n\n  invariant(\n    typeof FormData === \"function\",\n    \"FormData is not available in this environment\"\n  );\n\n  let searchParams: URLSearchParams;\n  let formData: FormData;\n\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n\n  let submission: Submission = {\n    formMethod,\n    formAction,\n    formEncType:\n      (opts && opts.formEncType) || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined,\n  };\n\n  if (isMutationMethod(submission.formMethod)) {\n    return { path, submission };\n  }\n\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = `?${searchParams}`;\n\n  return { path: createPath(parsedPath), submission };\n}\n\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(\n  matches: AgnosticDataRouteMatch[],\n  boundaryId: string\n) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\n\nfunction getMatchesToLoad(\n  history: History,\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  submission: Submission | undefined,\n  location: Location,\n  isInitialLoad: boolean,\n  skipActionErrorRevalidation: boolean,\n  isRevalidationRequired: boolean,\n  cancelledDeferredRoutes: string[],\n  cancelledFetcherLoads: string[],\n  deletedFetchers: Set<string>,\n  fetchLoadMatches: Map<string, FetchLoadMatch>,\n  fetchRedirectIds: Set<string>,\n  routesToUse: AgnosticDataRouteObject[],\n  basename: string | undefined,\n  pendingActionResult?: PendingActionResult\n): [AgnosticDataRouteMatch[], RevalidatingFetcher[]] {\n  let actionResult = pendingActionResult\n    ? isErrorResult(pendingActionResult[1])\n      ? pendingActionResult[1].error\n      : pendingActionResult[1].data\n    : undefined;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId =\n    pendingActionResult && isErrorResult(pendingActionResult[1])\n      ? pendingActionResult[0]\n      : undefined;\n  let boundaryMatches = boundaryId\n    ? getLoaderMatchesUntilBoundary(matches, boundaryId)\n    : matches;\n\n  // Don't revalidate loaders by default after action 4xx/5xx responses\n  // when the flag is enabled.  They can still opt-into revalidation via\n  // `shouldRevalidate` via `actionResult`\n  let actionStatus = pendingActionResult\n    ? pendingActionResult[1].statusCode\n    : undefined;\n  let shouldSkipRevalidation =\n    skipActionErrorRevalidation && actionStatus && actionStatus >= 400;\n\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    let { route } = match;\n    if (route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n\n    if (route.loader == null) {\n      return false;\n    }\n\n    if (isInitialLoad) {\n      if (typeof route.loader !== \"function\" || route.loader.hydrate) {\n        return true;\n      }\n      return (\n        state.loaderData[route.id] === undefined &&\n        // Don't re-run if the loader ran and threw an error\n        (!state.errors || state.errors[route.id] === undefined)\n      );\n    }\n\n    // Always call the loader on new route instances and pending defer cancellations\n    if (\n      isNewLoader(state.loaderData, state.matches[index], match) ||\n      cancelledDeferredRoutes.some((id) => id === match.route.id)\n    ) {\n      return true;\n    }\n\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n\n    return shouldRevalidateLoader(match, {\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params,\n      ...submission,\n      actionResult,\n      unstable_actionStatus: actionStatus,\n      defaultShouldRevalidate: shouldSkipRevalidation\n        ? false\n        : // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n          isRevalidationRequired ||\n          currentUrl.pathname + currentUrl.search ===\n            nextUrl.pathname + nextUrl.search ||\n          // Search params affect all loaders\n          currentUrl.search !== nextUrl.search ||\n          isNewRouteInstance(currentRouteMatch, nextRouteMatch),\n    });\n  });\n\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers: RevalidatingFetcher[] = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate:\n    //  - on initial load (shouldn't be any fetchers then anyway)\n    //  - if fetcher won't be present in the subsequent render\n    //    - no longer matches the URL (v7_fetcherPersist=false)\n    //    - was unmounted but persisted due to v7_fetcherPersist=true\n    if (\n      isInitialLoad ||\n      !matches.some((m) => m.route.id === f.routeId) ||\n      deletedFetchers.has(key)\n    ) {\n      return;\n    }\n\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null,\n      });\n      return;\n    }\n\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (\n      fetcher &&\n      fetcher.state !== \"idle\" &&\n      fetcher.data === undefined\n    ) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, {\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params,\n        ...submission,\n        actionResult,\n        unstable_actionStatus: actionStatus,\n        defaultShouldRevalidate: shouldSkipRevalidation\n          ? false\n          : isRevalidationRequired,\n      });\n    }\n\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController(),\n      });\n    }\n  });\n\n  return [navigationMatches, revalidatingFetchers];\n}\n\nfunction isNewLoader(\n  currentLoaderData: RouteData,\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let isNew =\n    // [a] -> [a, b]\n    !currentMatch ||\n    // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\n\nfunction isNewRouteInstance(\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    (currentPath != null &&\n      currentPath.endsWith(\"*\") &&\n      currentMatch.params[\"*\"] !== match.params[\"*\"])\n  );\n}\n\nfunction shouldRevalidateLoader(\n  loaderMatch: AgnosticDataRouteMatch,\n  arg: ShouldRevalidateFunctionArgs\n) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n\n  return arg.defaultShouldRevalidate;\n}\n\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(\n  route: AgnosticDataRouteObject,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  manifest: RouteManifest\n) {\n  if (!route.lazy) {\n    return;\n  }\n\n  let lazyRoute = await route.lazy();\n\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates: Record<string, any> = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue =\n      routeToUpdate[lazyRouteProperty as keyof typeof routeToUpdate];\n\n    let isPropertyStaticallyDefined =\n      staticRouteValue !== undefined &&\n      // This property isn't static since it should always be updated based\n      // on the route updates\n      lazyRouteProperty !== \"hasErrorBoundary\";\n\n    warning(\n      !isPropertyStaticallyDefined,\n      `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" ` +\n        `defined but its lazy function is also returning a value for this property. ` +\n        `The lazy route property \"${lazyRouteProperty}\" will be ignored.`\n    );\n\n    if (\n      !isPropertyStaticallyDefined &&\n      !immutableRouteKeys.has(lazyRouteProperty as ImmutableRouteKey)\n    ) {\n      routeUpdates[lazyRouteProperty] =\n        lazyRoute[lazyRouteProperty as keyof typeof lazyRoute];\n    }\n  }\n\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, {\n    // To keep things framework agnostic, we use the provided\n    // `mapRouteProperties` (or wrapped `detectErrorBoundary`) function to\n    // set the framework-aware properties (`element`/`hasErrorBoundary`) since\n    // the logic will differ between frameworks.\n    ...mapRouteProperties(routeToUpdate),\n    lazy: undefined,\n  });\n}\n\n// Default implementation of `dataStrategy` which fetches all loaders in parallel\nfunction defaultDataStrategy(\n  opts: DataStrategyFunctionArgs\n): ReturnType<DataStrategyFunction> {\n  return Promise.all(opts.matches.map((m) => m.resolve()));\n}\n\nasync function callDataStrategyImpl(\n  dataStrategyImpl: DataStrategyFunction,\n  type: \"loader\" | \"action\",\n  request: Request,\n  matchesToLoad: AgnosticDataRouteMatch[],\n  matches: AgnosticDataRouteMatch[],\n  manifest: RouteManifest,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  requestContext?: unknown\n): Promise<HandlerResult[]> {\n  let routeIdsToLoad = matchesToLoad.reduce(\n    (acc, m) => acc.add(m.route.id),\n    new Set<string>()\n  );\n  let loadedMatches = new Set<string>();\n\n  // Send all matches here to allow for a middleware-type implementation.\n  // handler will be a no-op for unneeded routes and we filter those results\n  // back out below.\n  let results = await dataStrategyImpl({\n    matches: matches.map((match) => {\n      let shouldLoad = routeIdsToLoad.has(match.route.id);\n      // `resolve` encapsulates the route.lazy, executing the\n      // loader/action, and mapping return values/thrown errors to a\n      // HandlerResult.  Users can pass a callback to take fine-grained control\n      // over the execution of the loader/action\n      let resolve: DataStrategyMatch[\"resolve\"] = (handlerOverride) => {\n        loadedMatches.add(match.route.id);\n        return shouldLoad\n          ? callLoaderOrAction(\n              type,\n              request,\n              match,\n              manifest,\n              mapRouteProperties,\n              handlerOverride,\n              requestContext\n            )\n          : Promise.resolve({ type: ResultType.data, result: undefined });\n      };\n\n      return {\n        ...match,\n        shouldLoad,\n        resolve,\n      };\n    }),\n    request,\n    params: matches[0].params,\n    context: requestContext,\n  });\n\n  // Throw if any loadRoute implementations not called since they are what\n  // ensures a route is fully loaded\n  matches.forEach((m) =>\n    invariant(\n      loadedMatches.has(m.route.id),\n      `\\`match.resolve()\\` was not called for route id \"${m.route.id}\". ` +\n        \"You must call `match.resolve()` on every match passed to \" +\n        \"`dataStrategy` to ensure all routes are properly loaded.\"\n    )\n  );\n\n  // Filter out any middleware-only matches for which we didn't need to run handlers\n  return results.filter((_, i) => routeIdsToLoad.has(matches[i].route.id));\n}\n\n// Default logic for calling a loader/action is the user has no specified a dataStrategy\nasync function callLoaderOrAction(\n  type: \"loader\" | \"action\",\n  request: Request,\n  match: AgnosticDataRouteMatch,\n  manifest: RouteManifest,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  handlerOverride: Parameters<DataStrategyMatch[\"resolve\"]>[0],\n  staticContext?: unknown\n): Promise<HandlerResult> {\n  let result: HandlerResult;\n  let onReject: (() => void) | undefined;\n\n  let runHandler = (\n    handler: AgnosticRouteObject[\"loader\"] | AgnosticRouteObject[\"action\"]\n  ): Promise<HandlerResult> => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject: () => void;\n    // This will never resolve so safe to type it as Promise<HandlerResult> to\n    // satisfy the function return value\n    let abortPromise = new Promise<HandlerResult>((_, r) => (reject = r));\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n\n    let actualHandler = (ctx?: unknown) => {\n      if (typeof handler !== \"function\") {\n        return Promise.reject(\n          new Error(\n            `You cannot call the handler for a route which defines a boolean ` +\n              `\"${type}\" [routeId: ${match.route.id}]`\n          )\n        );\n      }\n      return handler(\n        {\n          request,\n          params: match.params,\n          context: staticContext,\n        },\n        ...(ctx !== undefined ? [ctx] : [])\n      );\n    };\n\n    let handlerPromise: Promise<HandlerResult>;\n    if (handlerOverride) {\n      handlerPromise = handlerOverride((ctx: unknown) => actualHandler(ctx));\n    } else {\n      handlerPromise = (async () => {\n        try {\n          let val = await actualHandler();\n          return { type: \"data\", result: val };\n        } catch (e) {\n          return { type: \"error\", result: e };\n        }\n      })();\n    }\n\n    return Promise.race([handlerPromise, abortPromise]);\n  };\n\n  try {\n    let handler = match.route[type];\n\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let [value] = await Promise.all([\n          // If the handler throws, don't let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler).catch((e) => {\n            handlerError = e;\n          }),\n          loadLazyRouteModule(match.route, mapRouteProperties, manifest),\n        ]);\n        if (handlerError !== undefined) {\n          throw handlerError;\n        }\n        result = value!;\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n\n        handler = match.route[type];\n        if (handler) {\n          // Handler still runs even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id,\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return { type: ResultType.data, result: undefined };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname,\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n\n    invariant(\n      result.result !== undefined,\n      `You defined ${type === \"action\" ? \"an action\" : \"a loader\"} for route ` +\n        `\"${match.route.id}\" but didn't return anything from your \\`${type}\\` ` +\n        `function. Please return a value or \\`null\\`.`\n    );\n  } catch (e) {\n    // We should already be catching and converting normal handler executions to\n    // HandlerResults and returning them, so anything that throws here is an\n    // unexpected error we still need to wrap\n    return { type: ResultType.error, result: e };\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n\n  return result;\n}\n\nasync function convertHandlerResultToDataResult(\n  handlerResult: HandlerResult\n): Promise<DataResult> {\n  let { result, type, status } = handlerResult;\n\n  if (isResponse(result)) {\n    let data: any;\n\n    try {\n      let contentType = result.headers.get(\"Content-Type\");\n      // Check between word boundaries instead of startsWith() due to the last\n      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n        if (result.body == null) {\n          data = null;\n        } else {\n          data = await result.json();\n        }\n      } else {\n        data = await result.text();\n      }\n    } catch (e) {\n      return { type: ResultType.error, error: e };\n    }\n\n    if (type === ResultType.error) {\n      return {\n        type: ResultType.error,\n        error: new ErrorResponseImpl(result.status, result.statusText, data),\n        statusCode: result.status,\n        headers: result.headers,\n      };\n    }\n\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers,\n    };\n  }\n\n  if (type === ResultType.error) {\n    return {\n      type: ResultType.error,\n      error: result,\n      statusCode: isRouteErrorResponse(result) ? result.status : status,\n    };\n  }\n\n  if (isDeferredData(result)) {\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: result.init?.status,\n      headers: result.init?.headers && new Headers(result.init.headers),\n    };\n  }\n\n  return { type: ResultType.data, data: result, statusCode: status };\n}\n\n// Support relative routing in internal redirects\nfunction normalizeRelativeRoutingRedirectResponse(\n  response: Response,\n  request: Request,\n  routeId: string,\n  matches: AgnosticDataRouteMatch[],\n  basename: string,\n  v7_relativeSplatPath: boolean\n) {\n  let location = response.headers.get(\"Location\");\n  invariant(\n    location,\n    \"Redirects returned/thrown from loaders/actions must have a Location header\"\n  );\n\n  if (!ABSOLUTE_URL_REGEX.test(location)) {\n    let trimmedMatches = matches.slice(\n      0,\n      matches.findIndex((m) => m.route.id === routeId) + 1\n    );\n    location = normalizeTo(\n      new URL(request.url),\n      trimmedMatches,\n      basename,\n      true,\n      location,\n      v7_relativeSplatPath\n    );\n    response.headers.set(\"Location\", location);\n  }\n\n  return response;\n}\n\nfunction normalizeRedirectLocation(\n  location: string,\n  currentUrl: URL,\n  basename: string\n): string {\n  if (ABSOLUTE_URL_REGEX.test(location)) {\n    // Strip off the protocol+origin for same-origin + same-basename absolute redirects\n    let normalizedLocation = location;\n    let url = normalizedLocation.startsWith(\"//\")\n      ? new URL(currentUrl.protocol + normalizedLocation)\n      : new URL(normalizedLocation);\n    let isSameBasename = stripBasename(url.pathname, basename) != null;\n    if (url.origin === currentUrl.origin && isSameBasename) {\n      return url.pathname + url.search + url.hash;\n    }\n  }\n  return location;\n}\n\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(\n  history: History,\n  location: string | Location,\n  signal: AbortSignal,\n  submission?: Submission\n): Request {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init: RequestInit = { signal };\n\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let { formMethod, formEncType } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({ \"Content-Type\": formEncType });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (\n      formEncType === \"application/x-www-form-urlencoded\" &&\n      submission.formData\n    ) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n\n  return new Request(url, init);\n}\n\nfunction convertFormDataToSearchParams(formData: FormData): URLSearchParams {\n  let searchParams = new URLSearchParams();\n\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n\n  return searchParams;\n}\n\nfunction convertSearchParamsToFormData(\n  searchParams: URLSearchParams\n): FormData {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\n\nfunction processRouteLoaderData(\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingActionResult: PendingActionResult | undefined,\n  activeDeferreds: Map<string, DeferredData>,\n  skipLoaderErrorBubbling: boolean\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors: RouterState[\"errors\"] | null;\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n} {\n  // Fill in loaderData/errors from our loaders\n  let loaderData: RouterState[\"loaderData\"] = {};\n  let errors: RouterState[\"errors\"] | null = null;\n  let statusCode: number | undefined;\n  let foundError = false;\n  let loaderHeaders: Record<string, Headers> = {};\n  let pendingError =\n    pendingActionResult && isErrorResult(pendingActionResult[1])\n      ? pendingActionResult[1].error\n      : undefined;\n\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(\n      !isRedirectResult(result),\n      \"Cannot handle redirect results in processLoaderData\"\n    );\n    if (isErrorResult(result)) {\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError !== undefined) {\n        error = pendingError;\n        pendingError = undefined;\n      }\n\n      errors = errors || {};\n\n      if (skipLoaderErrorBubbling) {\n        errors[id] = error;\n      } else {\n        // Look upwards from the matched route for the closest ancestor error\n        // boundary, defaulting to the root match.  Prefer higher error values\n        // if lower errors bubble to the same boundary\n        let boundaryMatch = findNearestBoundary(matches, id);\n        if (errors[boundaryMatch.route.id] == null) {\n          errors[boundaryMatch.route.id] = error;\n        }\n      }\n\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n        // Error status codes always override success status codes, but if all\n        // loaders are successful we take the deepest status code.\n        if (\n          result.statusCode != null &&\n          result.statusCode !== 200 &&\n          !foundError\n        ) {\n          statusCode = result.statusCode;\n        }\n        if (result.headers) {\n          loaderHeaders[id] = result.headers;\n        }\n      } else {\n        loaderData[id] = result.data;\n        // Error status codes always override success status codes, but if all\n        // loaders are successful we take the deepest status code.\n        if (result.statusCode && result.statusCode !== 200 && !foundError) {\n          statusCode = result.statusCode;\n        }\n        if (result.headers) {\n          loaderHeaders[id] = result.headers;\n        }\n      }\n    }\n  });\n\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError !== undefined && pendingActionResult) {\n    errors = { [pendingActionResult[0]]: pendingError };\n    loaderData[pendingActionResult[0]] = undefined;\n  }\n\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders,\n  };\n}\n\nfunction processLoaderData(\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingActionResult: PendingActionResult | undefined,\n  revalidatingFetchers: RevalidatingFetcher[],\n  fetcherResults: DataResult[],\n  activeDeferreds: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors?: RouterState[\"errors\"];\n} {\n  let { loaderData, errors } = processRouteLoaderData(\n    matches,\n    matchesToLoad,\n    results,\n    pendingActionResult,\n    activeDeferreds,\n    false // This method is only called client side so we always want to bubble\n  );\n\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let { key, match, controller } = revalidatingFetchers[index];\n    invariant(\n      fetcherResults !== undefined && fetcherResults[index] !== undefined,\n      \"Did not find corresponding fetcher result\"\n    );\n    let result = fetcherResults[index];\n\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = {\n          ...errors,\n          [boundaryMatch.route.id]: result.error,\n        };\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  return { loaderData, errors };\n}\n\nfunction mergeLoaderData(\n  loaderData: RouteData,\n  newLoaderData: RouteData,\n  matches: AgnosticDataRouteMatch[],\n  errors: RouteData | null | undefined\n): RouteData {\n  let mergedLoaderData = { ...newLoaderData };\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      } else {\n        // No-op - this is so we ignore existing data if we have a key in the\n        // incoming object with an undefined value, which is how we unset a prior\n        // loaderData if we encounter a loader error\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n\nfunction getActionDataForCommit(\n  pendingActionResult: PendingActionResult | undefined\n) {\n  if (!pendingActionResult) {\n    return {};\n  }\n  return isErrorResult(pendingActionResult[1])\n    ? {\n        // Clear out prior actionData on errors\n        actionData: {},\n      }\n    : {\n        actionData: {\n          [pendingActionResult[0]]: pendingActionResult[1].data,\n        },\n      };\n}\n\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(\n  matches: AgnosticDataRouteMatch[],\n  routeId?: string\n): AgnosticDataRouteMatch {\n  let eligibleMatches = routeId\n    ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1)\n    : [...matches];\n  return (\n    eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) ||\n    matches[0]\n  );\n}\n\nfunction getShortCircuitMatches(routes: AgnosticDataRouteObject[]): {\n  matches: AgnosticDataRouteMatch[];\n  route: AgnosticDataRouteObject;\n} {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route =\n    routes.length === 1\n      ? routes[0]\n      : routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n          id: `__shim-error-route__`,\n        };\n\n  return {\n    matches: [\n      {\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route,\n      },\n    ],\n    route,\n  };\n}\n\nfunction getInternalRouterError(\n  status: number,\n  {\n    pathname,\n    routeId,\n    method,\n    type,\n  }: {\n    pathname?: string;\n    routeId?: string;\n    method?: string;\n    type?: \"defer-action\" | \"invalid-body\";\n  } = {}\n) {\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method} request to \"${pathname}\" but ` +\n        `did not provide a \\`loader\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = `No route matches URL \"${pathname}\"`;\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method.toUpperCase()} request to \"${pathname}\" but ` +\n        `did not provide an \\`action\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (method) {\n      errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n    }\n  }\n\n  return new ErrorResponseImpl(\n    status || 500,\n    statusText,\n    new Error(errorMessage),\n    true\n  );\n}\n\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(\n  results: DataResult[]\n): { result: RedirectResult; idx: number } | undefined {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return { result, idx: i };\n    }\n  }\n}\n\nfunction stripHashFromPath(path: To) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath({ ...parsedPath, hash: \"\" });\n}\n\nfunction isHashChangeOnly(a: Location, b: Location): boolean {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\n\nfunction isHandlerResult(result: unknown): result is HandlerResult {\n  return (\n    result != null &&\n    typeof result === \"object\" &&\n    \"type\" in result &&\n    \"result\" in result &&\n    (result.type === ResultType.data || result.type === ResultType.error)\n  );\n}\n\nfunction isRedirectHandlerResult(result: HandlerResult) {\n  return (\n    isResponse(result.result) && redirectStatusCodes.has(result.result.status)\n  );\n}\n\nfunction isDeferredResult(result: DataResult): result is DeferredResult {\n  return result.type === ResultType.deferred;\n}\n\nfunction isErrorResult(result: DataResult): result is ErrorResult {\n  return result.type === ResultType.error;\n}\n\nfunction isRedirectResult(result?: DataResult): result is RedirectResult {\n  return (result && result.type) === ResultType.redirect;\n}\n\nexport function isDeferredData(value: any): value is DeferredData {\n  let deferred: DeferredData = value;\n  return (\n    deferred &&\n    typeof deferred === \"object\" &&\n    typeof deferred.data === \"object\" &&\n    typeof deferred.subscribe === \"function\" &&\n    typeof deferred.cancel === \"function\" &&\n    typeof deferred.resolveData === \"function\"\n  );\n}\n\nfunction isResponse(value: any): value is Response {\n  return (\n    value != null &&\n    typeof value.status === \"number\" &&\n    typeof value.statusText === \"string\" &&\n    typeof value.headers === \"object\" &&\n    typeof value.body !== \"undefined\"\n  );\n}\n\nfunction isRedirectResponse(result: any): result is Response {\n  if (!isResponse(result)) {\n    return false;\n  }\n\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\n\nfunction isValidMethod(method: string): method is FormMethod | V7_FormMethod {\n  return validRequestMethods.has(method.toLowerCase() as FormMethod);\n}\n\nfunction isMutationMethod(\n  method: string\n): method is MutationFormMethod | V7_MutationFormMethod {\n  return validMutationMethods.has(method.toLowerCase() as MutationFormMethod);\n}\n\nasync function resolveDeferredResults(\n  currentMatches: AgnosticDataRouteMatch[],\n  matchesToLoad: (AgnosticDataRouteMatch | null)[],\n  results: DataResult[],\n  signals: (AbortSignal | null)[],\n  isFetcher: boolean,\n  currentLoaderData?: RouteData\n) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n\n    let currentMatch = currentMatches.find(\n      (m) => m.route.id === match!.route.id\n    );\n    let isRevalidatingLoader =\n      currentMatch != null &&\n      !isNewRouteInstance(currentMatch, match) &&\n      (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(\n        signal,\n        \"Expected an AbortSignal for revalidating fetcher deferred result\"\n      );\n      await resolveDeferredData(result, signal, isFetcher).then((result) => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\n\nasync function resolveDeferredData(\n  result: DeferredResult,\n  signal: AbortSignal,\n  unwrap = false\n): Promise<SuccessResult | ErrorResult | undefined> {\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData,\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e,\n      };\n    }\n  }\n\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data,\n  };\n}\n\nfunction hasNakedIndexQuery(search: string): boolean {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\n\nfunction getTargetMatch(\n  matches: AgnosticDataRouteMatch[],\n  location: Location | string\n) {\n  let search =\n    typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (\n    matches[matches.length - 1].route.index &&\n    hasNakedIndexQuery(search || \"\")\n  ) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\n\nfunction getSubmissionFromNavigation(\n  navigation: Navigation\n): Submission | undefined {\n  let { formMethod, formAction, formEncType, text, formData, json } =\n    navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text,\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined,\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined,\n    };\n  }\n}\n\nfunction getLoadingNavigation(\n  location: Location,\n  submission?: Submission\n): NavigationStates[\"Loading\"] {\n  if (submission) {\n    let navigation: NavigationStates[\"Loading\"] = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n    };\n    return navigation;\n  } else {\n    let navigation: NavigationStates[\"Loading\"] = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n    };\n    return navigation;\n  }\n}\n\nfunction getSubmittingNavigation(\n  location: Location,\n  submission: Submission\n): NavigationStates[\"Submitting\"] {\n  let navigation: NavigationStates[\"Submitting\"] = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n  };\n  return navigation;\n}\n\nfunction getLoadingFetcher(\n  submission?: Submission,\n  data?: Fetcher[\"data\"]\n): FetcherStates[\"Loading\"] {\n  if (submission) {\n    let fetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data,\n    };\n    return fetcher;\n  } else {\n    let fetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data,\n    };\n    return fetcher;\n  }\n}\n\nfunction getSubmittingFetcher(\n  submission: Submission,\n  existingFetcher?: Fetcher\n): FetcherStates[\"Submitting\"] {\n  let fetcher: FetcherStates[\"Submitting\"] = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined,\n  };\n  return fetcher;\n}\n\nfunction getDoneFetcher(data: Fetcher[\"data\"]): FetcherStates[\"Idle\"] {\n  let fetcher: FetcherStates[\"Idle\"] = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data,\n  };\n  return fetcher;\n}\n\nfunction restoreAppliedTransitions(\n  _window: Window,\n  transitions: Map<string, Set<string>>\n) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(\n      TRANSITIONS_STORAGE_KEY\n    );\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n    // no-op, use default empty object\n  }\n}\n\nfunction persistAppliedTransitions(\n  _window: Window,\n  transitions: Map<string, Set<string>>\n) {\n  if (transitions.size > 0) {\n    let json: Record<string, string[]> = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(\n        TRANSITIONS_STORAGE_KEY,\n        JSON.stringify(json)\n      );\n    } catch (error) {\n      warning(\n        false,\n        `Failed to save applied view transitions in sessionStorage (${error}).`\n      );\n    }\n  }\n}\n\n//#endregion\n","import useEffect from './useIsomorphicEffect';\nimport { useState } from 'react';\nconst matchersByWindow = new WeakMap();\nconst getMatcher = (query, targetWindow) => {\n  if (!query || !targetWindow) return undefined;\n  const matchers = matchersByWindow.get(targetWindow) || new Map();\n  matchersByWindow.set(targetWindow, matchers);\n  let mql = matchers.get(query);\n  if (!mql) {\n    mql = targetWindow.matchMedia(query);\n    mql.refCount = 0;\n    matchers.set(mql.media, mql);\n  }\n  return mql;\n};\n/**\n * Match a media query and get updates as the match changes. The media string is\n * passed directly to `window.matchMedia` and run as a Layout Effect, so initial\n * matches are returned before the browser has a chance to paint.\n *\n * ```tsx\n * function Page() {\n *   const isWide = useMediaQuery('min-width: 1000px')\n *\n *   return isWide ? \"very wide\" : 'not so wide'\n * }\n * ```\n *\n * Media query lists are also reused globally, hook calls for the same query\n * will only create a matcher once under the hood.\n *\n * @param query A media query\n * @param targetWindow The window to match against, uses the globally available one as a default.\n */\nexport default function useMediaQuery(query, targetWindow = typeof window === 'undefined' ? undefined : window) {\n  const mql = getMatcher(query, targetWindow);\n  const [matches, setMatches] = useState(() => mql ? mql.matches : false);\n  useEffect(() => {\n    let mql = getMatcher(query, targetWindow);\n    if (!mql) {\n      return setMatches(false);\n    }\n    let matchers = matchersByWindow.get(targetWindow);\n    const handleChange = () => {\n      setMatches(mql.matches);\n    };\n    mql.refCount++;\n    mql.addListener(handleChange);\n    handleChange();\n    return () => {\n      mql.removeListener(handleChange);\n      mql.refCount--;\n      if (mql.refCount <= 0) {\n        matchers == null ? void 0 : matchers.delete(mql.media);\n      }\n      mql = undefined;\n    };\n  }, [query]);\n  return matches;\n}","import useMediaQuery from './useMediaQuery';\nimport { useMemo } from 'react';\n/**\n * Create a responsive hook we a set of breakpoint names and widths.\n * You can use any valid css units as well as a numbers (for pixels).\n *\n * **NOTE:** The object key order is important! it's assumed to be in order from smallest to largest\n *\n * ```ts\n * const useBreakpoint = createBreakpointHook({\n *  xs: 0,\n *  sm: 576,\n *  md: 768,\n *  lg: 992,\n *  xl: 1200,\n * })\n * ```\n *\n * **Watch out!** using string values will sometimes construct media queries using css `calc()` which\n * is NOT supported in media queries by all browsers at the moment. use numbers for\n * the widest range of browser support.\n *\n * @param breakpointValues A object hash of names to breakpoint dimensions\n */\nexport function createBreakpointHook(breakpointValues) {\n  const names = Object.keys(breakpointValues);\n  function and(query, next) {\n    if (query === next) {\n      return next;\n    }\n    return query ? `${query} and ${next}` : next;\n  }\n  function getNext(breakpoint) {\n    return names[Math.min(names.indexOf(breakpoint) + 1, names.length - 1)];\n  }\n  function getMaxQuery(breakpoint) {\n    const next = getNext(breakpoint);\n    let value = breakpointValues[next];\n    if (typeof value === 'number') value = `${value - 0.2}px`;else value = `calc(${value} - 0.2px)`;\n    return `(max-width: ${value})`;\n  }\n  function getMinQuery(breakpoint) {\n    let value = breakpointValues[breakpoint];\n    if (typeof value === 'number') {\n      value = `${value}px`;\n    }\n    return `(min-width: ${value})`;\n  }\n\n  /**\n   * Match a set of breakpoints\n   *\n   * ```tsx\n   * const MidSizeOnly = () => {\n   *   const isMid = useBreakpoint({ lg: 'down', sm: 'up' });\n   *\n   *   if (isMid) return <div>On a Reasonable sized Screen!</div>\n   *   return null;\n   * }\n   * ```\n   * @param breakpointMap An object map of breakpoints and directions, queries are constructed using \"and\" to join\n   * breakpoints together\n   * @param window Optionally specify the target window to match against (useful when rendering into iframes)\n   */\n\n  /**\n   * Match a single breakpoint exactly, up, or down.\n   *\n   * ```tsx\n   * const PhoneOnly = () => {\n   *   const isSmall = useBreakpoint('sm', 'down');\n   *\n   *   if (isSmall) return <div>On a Small Screen!</div>\n   *   return null;\n   * }\n   * ```\n   *\n   * @param breakpoint The breakpoint key\n   * @param direction A direction 'up' for a max, 'down' for min, true to match only the breakpoint\n   * @param window Optionally specify the target window to match against (useful when rendering into iframes)\n   */\n\n  function useBreakpoint(breakpointOrMap, direction, window) {\n    let breakpointMap;\n    if (typeof breakpointOrMap === 'object') {\n      breakpointMap = breakpointOrMap;\n      window = direction;\n      direction = true;\n    } else {\n      direction = direction || true;\n      breakpointMap = {\n        [breakpointOrMap]: direction\n      };\n    }\n    let query = useMemo(() => Object.entries(breakpointMap).reduce((query, [key, direction]) => {\n      if (direction === 'up' || direction === true) {\n        query = and(query, getMinQuery(key));\n      }\n      if (direction === 'down' || direction === true) {\n        query = and(query, getMaxQuery(key));\n      }\n      return query;\n    }, ''), [JSON.stringify(breakpointMap)]);\n    return useMediaQuery(query, window);\n  }\n  return useBreakpoint;\n}\nconst useBreakpoint = createBreakpointHook({\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n});\nexport default useBreakpoint;","import { useState } from 'react';\n\n/**\n * A convenience hook around `useState` designed to be paired with\n * the component [callback ref](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs) api.\n * Callback refs are useful over `useRef()` when you need to respond to the ref being set\n * instead of lazily accessing it in an effect.\n *\n * ```ts\n * const [element, attachRef] = useCallbackRef<HTMLDivElement>()\n *\n * useEffect(() => {\n *   if (!element) return\n *\n *   const calendar = new FullCalendar.Calendar(element)\n *\n *   return () => {\n *     calendar.destroy()\n *   }\n * }, [element])\n *\n * return <div ref={attachRef} />\n * ```\n *\n * @category refs\n */\nexport default function useCallbackRef() {\n  return useState(null);\n}","import { useEffect, useRef } from 'react';\n\n/**\n * Creates a `Ref` whose value is updated in an effect, ensuring the most recent\n * value is the one rendered with. Generally only required for Concurrent mode usage\n * where previous work in `render()` may be discarded before being used.\n *\n * This is safe to access in an event handler.\n *\n * @param value The `Ref` value\n */\nfunction useCommittedRef(value) {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\nexport default useCommittedRef;","import { useCallback } from 'react';\nimport useCommittedRef from './useCommittedRef';\nexport default function useEventCallback(fn) {\n  const ref = useCommittedRef(fn);\n  return useCallback(function (...args) {\n    return ref.current && ref.current(...args);\n  }, [ref]);\n}","import { useEffect } from 'react';\nimport useEventCallback from './useEventCallback';\n/**\n * Attaches an event handler outside directly to specified DOM element\n * bypassing the react synthetic event system.\n *\n * @param element The target to listen for events on\n * @param event The DOM event name\n * @param handler An event handler\n * @param capture Whether or not to listen during the capture event phase\n */\nexport default function useEventListener(eventTarget, event, listener, capture = false) {\n  const handler = useEventCallback(listener);\n  useEffect(() => {\n    const target = typeof eventTarget === 'function' ? eventTarget() : eventTarget;\n    target.addEventListener(event, handler, capture);\n    return () => target.removeEventListener(event, handler, capture);\n  }, [eventTarget]);\n}","import { useReducer } from 'react';\n\n/**\n * Returns a function that triggers a component update. the hook equivalent to\n * `this.forceUpdate()` in a class component. In most cases using a state value directly\n * is preferable but may be required in some advanced usages of refs for interop or\n * when direct DOM manipulation is required.\n *\n * ```ts\n * const forceUpdate = useForceUpdate();\n *\n * const updateOnClick = useCallback(() => {\n *  forceUpdate()\n * }, [forceUpdate])\n *\n * return <button type=\"button\" onClick={updateOnClick}>Hi there</button>\n * ```\n */\nexport default function useForceUpdate() {\n  // The toggling state value is designed to defeat React optimizations for skipping\n  // updates when they are strictly equal to the last state value\n  const [, dispatch] = useReducer(state => !state, false);\n  return dispatch;\n}","import { useEffect, useLayoutEffect } from 'react';\nconst isReactNative = typeof global !== 'undefined' &&\n// @ts-ignore\nglobal.navigator &&\n// @ts-ignore\nglobal.navigator.product === 'ReactNative';\nconst isDOM = typeof document !== 'undefined';\n\n/**\n * Is `useLayoutEffect` in a DOM or React Native environment, otherwise resolves to useEffect\n * Only useful to avoid the console warning.\n *\n * PREFER `useEffect` UNLESS YOU KNOW WHAT YOU ARE DOING.\n *\n * @category effects\n */\nexport default isDOM || isReactNative ? useLayoutEffect : useEffect;","import { useMemo } from 'react';\nconst toFnRef = ref => !ref || typeof ref === 'function' ? ref : value => {\n  ref.current = value;\n};\nexport function mergeRefs(refA, refB) {\n  const a = toFnRef(refA);\n  const b = toFnRef(refB);\n  return value => {\n    if (a) a(value);\n    if (b) b(value);\n  };\n}\n\n/**\n * Create and returns a single callback ref composed from two other Refs.\n *\n * ```tsx\n * const Button = React.forwardRef((props, ref) => {\n *   const [element, attachRef] = useCallbackRef<HTMLButtonElement>();\n *   const mergedRef = useMergedRefs(ref, attachRef);\n *\n *   return <button ref={mergedRef} {...props}/>\n * })\n * ```\n *\n * @param refA A Callback or mutable Ref\n * @param refB A Callback or mutable Ref\n * @category refs\n */\nfunction useMergedRefs(refA, refB) {\n  return useMemo(() => mergeRefs(refA, refB), [refA, refB]);\n}\nexport default useMergedRefs;","import { useRef, useEffect } from 'react';\n\n/**\n * Track whether a component is current mounted. Generally less preferable than\n * properlly canceling effects so they don't run after a component is unmounted,\n * but helpful in cases where that isn't feasible, such as a `Promise` resolution.\n *\n * @returns a function that returns the current isMounted state of the component\n *\n * ```ts\n * const [data, setData] = useState(null)\n * const isMounted = useMounted()\n *\n * useEffect(() => {\n *   fetchdata().then((newData) => {\n *      if (isMounted()) {\n *        setData(newData);\n *      }\n *   })\n * })\n * ```\n */\nexport default function useMounted() {\n  const mounted = useRef(true);\n  const isMounted = useRef(() => mounted.current);\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  return isMounted.current;\n}","import { useEffect, useRef } from 'react';\n\n/**\n * Store the last of some value. Tracked via a `Ref` only updating it\n * after the component renders.\n *\n * Helpful if you need to compare a prop value to it's previous value during render.\n *\n * ```ts\n * function Component(props) {\n *   const lastProps = usePrevious(props)\n *\n *   if (lastProps.foo !== props.foo)\n *     resetValueFromProps(props.foo)\n * }\n * ```\n *\n * @param value the value to track\n */\nexport default function usePrevious(value) {\n  const ref = useRef(null);\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}","import { useMemo, useRef } from 'react';\nimport useMounted from './useMounted';\nimport useWillUnmount from './useWillUnmount';\n\n/*\n * Browsers including Internet Explorer, Chrome, Safari, and Firefox store the\n * delay as a 32-bit signed integer internally. This causes an integer overflow\n * when using delays larger than 2,147,483,647 ms (about 24.8 days),\n * resulting in the timeout being executed immediately.\n *\n * via: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\n */\nconst MAX_DELAY_MS = 2 ** 31 - 1;\nfunction setChainedTimeout(handleRef, fn, timeoutAtMs) {\n  const delayMs = timeoutAtMs - Date.now();\n  handleRef.current = delayMs <= MAX_DELAY_MS ? setTimeout(fn, delayMs) : setTimeout(() => setChainedTimeout(handleRef, fn, timeoutAtMs), MAX_DELAY_MS);\n}\n\n/**\n * Returns a controller object for setting a timeout that is properly cleaned up\n * once the component unmounts. New timeouts cancel and replace existing ones.\n *\n *\n *\n * ```tsx\n * const { set, clear } = useTimeout();\n * const [hello, showHello] = useState(false);\n * //Display hello after 5 seconds\n * set(() => showHello(true), 5000);\n * return (\n *   <div className=\"App\">\n *     {hello ? <h3>Hello</h3> : null}\n *   </div>\n * );\n * ```\n */\nexport default function useTimeout() {\n  const isMounted = useMounted();\n\n  // types are confused between node and web here IDK\n  const handleRef = useRef();\n  useWillUnmount(() => clearTimeout(handleRef.current));\n  return useMemo(() => {\n    const clear = () => clearTimeout(handleRef.current);\n    function set(fn, delayMs = 0) {\n      if (!isMounted()) return;\n      clear();\n      if (delayMs <= MAX_DELAY_MS) {\n        // For simplicity, if the timeout is short, just set a normal timeout.\n        handleRef.current = setTimeout(fn, delayMs);\n      } else {\n        setChainedTimeout(handleRef, fn, Date.now() + delayMs);\n      }\n    }\n    return {\n      set,\n      clear,\n      handleRef\n    };\n  }, []);\n}","import useUpdatedRef from './useUpdatedRef';\nimport { useEffect } from 'react';\n\n/**\n * Attach a callback that fires when a component unmounts\n *\n * @param fn Handler to run when the component unmounts\n * @category effects\n */\nexport default function useWillUnmount(fn) {\n  const onUnmount = useUpdatedRef(fn);\n  useEffect(() => () => onUnmount.current(), []);\n}","import { useRef } from 'react';\n\n/**\n * Returns a ref that is immediately updated with the new value\n *\n * @param value The Ref value\n * @category refs\n */\nexport default function useUpdatedRef(value) {\n  const valueRef = useRef(value);\n  valueRef.current = value;\n  return valueRef;\n}","import { useState } from 'react';\nimport useEffect from './useIsomorphicEffect';\nconst targetMap = new WeakMap();\nlet resizeObserver;\nfunction getResizeObserver() {\n  // eslint-disable-next-line no-return-assign\n  return resizeObserver = resizeObserver || new window.ResizeObserver(entries => {\n    entries.forEach(entry => {\n      const handler = targetMap.get(entry.target);\n      if (handler) handler(entry.contentRect);\n    });\n  });\n}\n\n/**\n * Efficiently observe size changes on an element. Depends on the `ResizeObserver` api,\n * and polyfills are needed in older browsers.\n *\n * ```ts\n * const [ref, attachRef] = useCallbackRef(null);\n *\n * const rect = useResizeObserver(ref);\n *\n * return (\n *  <div ref={attachRef}>\n *    {JSON.stringify(rect)}\n *  </div>\n * )\n * ```\n *\n * @param element The DOM element to observe\n */\nexport default function useResizeObserver(element) {\n  const [rect, setRect] = useState(null);\n  useEffect(() => {\n    if (!element) return;\n    getResizeObserver().observe(element);\n    setRect(element.getBoundingClientRect());\n    targetMap.set(element, rect => {\n      setRect(rect);\n    });\n    return () => {\n      targetMap.delete(element);\n    };\n  }, [element]);\n  return rect;\n}","const _excluded = [\"onKeyDown\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* eslint-disable jsx-a11y/no-static-element-interactions */\n/* eslint-disable jsx-a11y/anchor-has-content */\n\nimport * as React from 'react';\nimport { useEventCallback } from '@restart/hooks';\nimport { useButtonProps } from './Button';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function isTrivialHref(href) {\n  return !href || href.trim() === '#';\n}\n/**\n * An generic `<a>` component that covers a few A11y cases, ensuring that\n * cases where the `href` is missing or trivial like \"#\" are treated like buttons.\n */\nconst Anchor = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n      onKeyDown\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const [buttonProps] = useButtonProps(Object.assign({\n    tagName: 'a'\n  }, props));\n  const handleKeyDown = useEventCallback(e => {\n    buttonProps.onKeyDown(e);\n    onKeyDown == null ? void 0 : onKeyDown(e);\n  });\n  if (isTrivialHref(props.href) || props.role === 'button') {\n    return /*#__PURE__*/_jsx(\"a\", Object.assign({\n      ref: ref\n    }, props, buttonProps, {\n      onKeyDown: handleKeyDown\n    }));\n  }\n  return /*#__PURE__*/_jsx(\"a\", Object.assign({\n    ref: ref\n  }, props, {\n    onKeyDown: onKeyDown\n  }));\n});\nAnchor.displayName = 'Anchor';\nexport default Anchor;","const _excluded = [\"as\", \"disabled\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport * as React from 'react';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function isTrivialHref(href) {\n  return !href || href.trim() === '#';\n}\nexport function useButtonProps({\n  tagName,\n  disabled,\n  href,\n  target,\n  rel,\n  role,\n  onClick,\n  tabIndex = 0,\n  type\n}) {\n  if (!tagName) {\n    if (href != null || target != null || rel != null) {\n      tagName = 'a';\n    } else {\n      tagName = 'button';\n    }\n  }\n  const meta = {\n    tagName\n  };\n  if (tagName === 'button') {\n    return [{\n      type: type || 'button',\n      disabled\n    }, meta];\n  }\n  const handleClick = event => {\n    if (disabled || tagName === 'a' && isTrivialHref(href)) {\n      event.preventDefault();\n    }\n    if (disabled) {\n      event.stopPropagation();\n      return;\n    }\n    onClick == null ? void 0 : onClick(event);\n  };\n  const handleKeyDown = event => {\n    if (event.key === ' ') {\n      event.preventDefault();\n      handleClick(event);\n    }\n  };\n  if (tagName === 'a') {\n    // Ensure there's a href so Enter can trigger anchor button.\n    href || (href = '#');\n    if (disabled) {\n      href = undefined;\n    }\n  }\n  return [{\n    role: role != null ? role : 'button',\n    // explicitly undefined so that it overrides the props disabled in a spread\n    // e.g. <Tag {...props} {...hookProps} />\n    disabled: undefined,\n    tabIndex: disabled ? undefined : tabIndex,\n    href,\n    target: tagName === 'a' ? target : undefined,\n    'aria-disabled': !disabled ? undefined : disabled,\n    rel: tagName === 'a' ? rel : undefined,\n    onClick: handleClick,\n    onKeyDown: handleKeyDown\n  }, meta];\n}\nconst Button = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n      as: asProp,\n      disabled\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const [buttonProps, {\n    tagName: Component\n  }] = useButtonProps(Object.assign({\n    tagName: asProp,\n    disabled\n  }, props));\n  return /*#__PURE__*/_jsx(Component, Object.assign({}, props, buttonProps, {\n    ref: ref\n  }));\n});\nButton.displayName = 'Button';\nexport default Button;","export const ATTRIBUTE_PREFIX = `data-rr-ui-`;\nexport const PROPERTY_PREFIX = `rrUi`;\nexport function dataAttr(property) {\n  return `${ATTRIBUTE_PREFIX}${property}`;\n}\nexport function dataProp(property) {\n  return `${PROPERTY_PREFIX}${property}`;\n}","import qsa from 'dom-helpers/querySelectorAll';\nimport addEventListener from 'dom-helpers/addEventListener';\nimport { useCallback, useRef, useEffect, useMemo, useContext } from 'react';\nimport * as React from 'react';\nimport { useUncontrolledProp } from 'uncontrollable';\nimport usePrevious from '@restart/hooks/usePrevious';\nimport useForceUpdate from '@restart/hooks/useForceUpdate';\nimport useEventListener from '@restart/hooks/useEventListener';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport DropdownContext from './DropdownContext';\nimport DropdownMenu from './DropdownMenu';\nimport DropdownToggle, { isRoleMenu } from './DropdownToggle';\nimport DropdownItem from './DropdownItem';\nimport SelectableContext from './SelectableContext';\nimport { dataAttr } from './DataKey';\nimport useWindow from './useWindow';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction useRefWithUpdate() {\n  const forceUpdate = useForceUpdate();\n  const ref = useRef(null);\n  const attachRef = useCallback(element => {\n    ref.current = element;\n    // ensure that a menu set triggers an update for consumers\n    forceUpdate();\n  }, [forceUpdate]);\n  return [ref, attachRef];\n}\n\n/**\n * @displayName Dropdown\n * @public\n */\nfunction Dropdown({\n  defaultShow,\n  show: rawShow,\n  onSelect,\n  onToggle: rawOnToggle,\n  itemSelector = `* [${dataAttr('dropdown-item')}]`,\n  focusFirstItemOnShow,\n  placement = 'bottom-start',\n  children\n}) {\n  const window = useWindow();\n  const [show, onToggle] = useUncontrolledProp(rawShow, defaultShow, rawOnToggle);\n\n  // We use normal refs instead of useCallbackRef in order to populate the\n  // the value as quickly as possible, otherwise the effect to focus the element\n  // may run before the state value is set\n  const [menuRef, setMenu] = useRefWithUpdate();\n  const menuElement = menuRef.current;\n  const [toggleRef, setToggle] = useRefWithUpdate();\n  const toggleElement = toggleRef.current;\n  const lastShow = usePrevious(show);\n  const lastSourceEvent = useRef(null);\n  const focusInDropdown = useRef(false);\n  const onSelectCtx = useContext(SelectableContext);\n  const toggle = useCallback((nextShow, event, source = event == null ? void 0 : event.type) => {\n    onToggle(nextShow, {\n      originalEvent: event,\n      source\n    });\n  }, [onToggle]);\n  const handleSelect = useEventCallback((key, event) => {\n    onSelect == null ? void 0 : onSelect(key, event);\n    toggle(false, event, 'select');\n    if (!event.isPropagationStopped()) {\n      onSelectCtx == null ? void 0 : onSelectCtx(key, event);\n    }\n  });\n  const context = useMemo(() => ({\n    toggle,\n    placement,\n    show,\n    menuElement,\n    toggleElement,\n    setMenu,\n    setToggle\n  }), [toggle, placement, show, menuElement, toggleElement, setMenu, setToggle]);\n  if (menuElement && lastShow && !show) {\n    focusInDropdown.current = menuElement.contains(menuElement.ownerDocument.activeElement);\n  }\n  const focusToggle = useEventCallback(() => {\n    if (toggleElement && toggleElement.focus) {\n      toggleElement.focus();\n    }\n  });\n  const maybeFocusFirst = useEventCallback(() => {\n    const type = lastSourceEvent.current;\n    let focusType = focusFirstItemOnShow;\n    if (focusType == null) {\n      focusType = menuRef.current && isRoleMenu(menuRef.current) ? 'keyboard' : false;\n    }\n    if (focusType === false || focusType === 'keyboard' && !/^key.+$/.test(type)) {\n      return;\n    }\n    const first = qsa(menuRef.current, itemSelector)[0];\n    if (first && first.focus) first.focus();\n  });\n  useEffect(() => {\n    if (show) maybeFocusFirst();else if (focusInDropdown.current) {\n      focusInDropdown.current = false;\n      focusToggle();\n    }\n    // only `show` should be changing\n  }, [show, focusInDropdown, focusToggle, maybeFocusFirst]);\n  useEffect(() => {\n    lastSourceEvent.current = null;\n  });\n  const getNextFocusedChild = (current, offset) => {\n    if (!menuRef.current) return null;\n    const items = qsa(menuRef.current, itemSelector);\n    let index = items.indexOf(current) + offset;\n    index = Math.max(0, Math.min(index, items.length));\n    return items[index];\n  };\n  useEventListener(useCallback(() => window.document, [window]), 'keydown', event => {\n    var _menuRef$current, _toggleRef$current;\n    const {\n      key\n    } = event;\n    const target = event.target;\n    const fromMenu = (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.contains(target);\n    const fromToggle = (_toggleRef$current = toggleRef.current) == null ? void 0 : _toggleRef$current.contains(target);\n\n    // Second only to https://github.com/twbs/bootstrap/blob/8cfbf6933b8a0146ac3fbc369f19e520bd1ebdac/js/src/dropdown.js#L400\n    // in inscrutability\n    const isInput = /input|textarea/i.test(target.tagName);\n    if (isInput && (key === ' ' || key !== 'Escape' && fromMenu || key === 'Escape' && target.type === 'search')) {\n      return;\n    }\n    if (!fromMenu && !fromToggle) {\n      return;\n    }\n    if (key === 'Tab' && (!menuRef.current || !show)) {\n      return;\n    }\n    lastSourceEvent.current = event.type;\n    const meta = {\n      originalEvent: event,\n      source: event.type\n    };\n    switch (key) {\n      case 'ArrowUp':\n        {\n          const next = getNextFocusedChild(target, -1);\n          if (next && next.focus) next.focus();\n          event.preventDefault();\n          return;\n        }\n      case 'ArrowDown':\n        event.preventDefault();\n        if (!show) {\n          onToggle(true, meta);\n        } else {\n          const next = getNextFocusedChild(target, 1);\n          if (next && next.focus) next.focus();\n        }\n        return;\n      case 'Tab':\n        // on keydown the target is the element being tabbed FROM, we need that\n        // to know if this event is relevant to this dropdown (e.g. in this menu).\n        // On `keyup` the target is the element being tagged TO which we use to check\n        // if focus has left the menu\n        addEventListener(target.ownerDocument, 'keyup', e => {\n          var _menuRef$current2;\n          if (e.key === 'Tab' && !e.target || !((_menuRef$current2 = menuRef.current) != null && _menuRef$current2.contains(e.target))) {\n            onToggle(false, meta);\n          }\n        }, {\n          once: true\n        });\n        break;\n      case 'Escape':\n        if (key === 'Escape') {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        onToggle(false, meta);\n        break;\n      default:\n    }\n  });\n  return /*#__PURE__*/_jsx(SelectableContext.Provider, {\n    value: handleSelect,\n    children: /*#__PURE__*/_jsx(DropdownContext.Provider, {\n      value: context,\n      children: children\n    })\n  });\n}\nDropdown.displayName = 'Dropdown';\nDropdown.Menu = DropdownMenu;\nDropdown.Toggle = DropdownToggle;\nDropdown.Item = DropdownItem;\nexport default Dropdown;","import * as React from 'react';\nconst DropdownContext = /*#__PURE__*/React.createContext(null);\nexport default DropdownContext;","const _excluded = [\"eventKey\", \"disabled\", \"onClick\", \"active\", \"as\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport * as React from 'react';\nimport { useContext } from 'react';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport SelectableContext, { makeEventKey } from './SelectableContext';\nimport NavContext from './NavContext';\nimport Button from './Button';\nimport { dataAttr } from './DataKey';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n/**\n * Create a dropdown item. Returns a set of props for the dropdown item component\n * including an `onClick` handler that prevents selection when the item is disabled\n */\nexport function useDropdownItem({\n  key,\n  href,\n  active,\n  disabled,\n  onClick\n}) {\n  const onSelectCtx = useContext(SelectableContext);\n  const navContext = useContext(NavContext);\n  const {\n    activeKey\n  } = navContext || {};\n  const eventKey = makeEventKey(key, href);\n  const isActive = active == null && key != null ? makeEventKey(activeKey) === eventKey : active;\n  const handleClick = useEventCallback(event => {\n    if (disabled) return;\n    onClick == null ? void 0 : onClick(event);\n    if (onSelectCtx && !event.isPropagationStopped()) {\n      onSelectCtx(eventKey, event);\n    }\n  });\n  return [{\n    onClick: handleClick,\n    'aria-disabled': disabled || undefined,\n    'aria-selected': isActive,\n    [dataAttr('dropdown-item')]: ''\n  }, {\n    isActive\n  }];\n}\nconst DropdownItem = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n      eventKey,\n      disabled,\n      onClick,\n      active,\n      as: Component = Button\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const [dropdownItemProps] = useDropdownItem({\n    key: eventKey,\n    href: props.href,\n    disabled,\n    onClick,\n    active\n  });\n  return /*#__PURE__*/_jsx(Component, Object.assign({}, props, {\n    ref: ref\n  }, dropdownItemProps));\n});\nDropdownItem.displayName = 'DropdownItem';\nexport default DropdownItem;","const _excluded = [\"children\", \"usePopper\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport { useContext, useRef } from 'react';\nimport * as React from 'react';\nimport useCallbackRef from '@restart/hooks/useCallbackRef';\nimport DropdownContext from './DropdownContext';\nimport usePopper from './usePopper';\nimport useClickOutside from './useClickOutside';\nimport mergeOptionsWithPopperConfig from './mergeOptionsWithPopperConfig';\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst noop = () => {};\n\n/**\n * @memberOf Dropdown\n * @param {object}  options\n * @param {boolean} options.flip Automatically adjust the menu `drop` position based on viewport edge detection\n * @param {[number, number]} options.offset Define an offset distance between the Menu and the Toggle\n * @param {boolean} options.show Display the menu manually, ignored in the context of a `Dropdown`\n * @param {boolean} options.usePopper opt in/out of using PopperJS to position menus. When disabled you must position it yourself.\n * @param {string}  options.rootCloseEvent The pointer event to listen for when determining \"clicks outside\" the menu for triggering a close.\n * @param {object}  options.popperConfig Options passed to the [`usePopper`](/api/usePopper) hook.\n */\nexport function useDropdownMenu(options = {}) {\n  const context = useContext(DropdownContext);\n  const [arrowElement, attachArrowRef] = useCallbackRef();\n  const hasShownRef = useRef(false);\n  const {\n    flip,\n    offset,\n    rootCloseEvent,\n    fixed = false,\n    placement: placementOverride,\n    popperConfig = {},\n    enableEventListeners = true,\n    usePopper: shouldUsePopper = !!context\n  } = options;\n  const show = (context == null ? void 0 : context.show) == null ? !!options.show : context.show;\n  if (show && !hasShownRef.current) {\n    hasShownRef.current = true;\n  }\n  const handleClose = e => {\n    context == null ? void 0 : context.toggle(false, e);\n  };\n  const {\n    placement,\n    setMenu,\n    menuElement,\n    toggleElement\n  } = context || {};\n  const popper = usePopper(toggleElement, menuElement, mergeOptionsWithPopperConfig({\n    placement: placementOverride || placement || 'bottom-start',\n    enabled: shouldUsePopper,\n    enableEvents: enableEventListeners == null ? show : enableEventListeners,\n    offset,\n    flip,\n    fixed,\n    arrowElement,\n    popperConfig\n  }));\n  const menuProps = Object.assign({\n    ref: setMenu || noop,\n    'aria-labelledby': toggleElement == null ? void 0 : toggleElement.id\n  }, popper.attributes.popper, {\n    style: popper.styles.popper\n  });\n  const metadata = {\n    show,\n    placement,\n    hasShown: hasShownRef.current,\n    toggle: context == null ? void 0 : context.toggle,\n    popper: shouldUsePopper ? popper : null,\n    arrowProps: shouldUsePopper ? Object.assign({\n      ref: attachArrowRef\n    }, popper.attributes.arrow, {\n      style: popper.styles.arrow\n    }) : {}\n  };\n  useClickOutside(menuElement, handleClose, {\n    clickTrigger: rootCloseEvent,\n    disabled: !show\n  });\n  return [menuProps, metadata];\n}\n/**\n * Also exported as `<Dropdown.Menu>` from `Dropdown`.\n *\n * @displayName DropdownMenu\n * @memberOf Dropdown\n */\nfunction DropdownMenu(_ref) {\n  let {\n      children,\n      usePopper: usePopperProp = true\n    } = _ref,\n    options = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const [props, meta] = useDropdownMenu(Object.assign({}, options, {\n    usePopper: usePopperProp\n  }));\n  return /*#__PURE__*/_jsx(_Fragment, {\n    children: children(props, meta)\n  });\n}\nDropdownMenu.displayName = 'DropdownMenu';\n\n/** @component */\nexport default DropdownMenu;","import { useContext, useCallback } from 'react';\nimport * as React from 'react';\nimport { useSSRSafeId } from './ssr';\nimport DropdownContext from './DropdownContext';\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const isRoleMenu = el => {\n  var _el$getAttribute;\n  return ((_el$getAttribute = el.getAttribute('role')) == null ? void 0 : _el$getAttribute.toLowerCase()) === 'menu';\n};\nconst noop = () => {};\n\n/**\n * Wires up Dropdown toggle functionality, returning a set a props to attach\n * to the element that functions as the dropdown toggle (generally a button).\n *\n * @memberOf Dropdown\n */\nexport function useDropdownToggle() {\n  const id = useSSRSafeId();\n  const {\n    show = false,\n    toggle = noop,\n    setToggle,\n    menuElement\n  } = useContext(DropdownContext) || {};\n  const handleClick = useCallback(e => {\n    toggle(!show, e);\n  }, [show, toggle]);\n  const props = {\n    id,\n    ref: setToggle || noop,\n    onClick: handleClick,\n    'aria-expanded': !!show\n  };\n\n  // This is maybe better down in an effect, but\n  // the component is going to update anyway when the menu element\n  // is set so might return new props.\n  if (menuElement && isRoleMenu(menuElement)) {\n    props['aria-haspopup'] = true;\n  }\n  return [props, {\n    show,\n    toggle\n  }];\n}\n/**\n * Also exported as `<Dropdown.Toggle>` from `Dropdown`.\n *\n * @displayName DropdownToggle\n * @memberOf Dropdown\n */\nfunction DropdownToggle({\n  children\n}) {\n  const [props, meta] = useDropdownToggle();\n  return /*#__PURE__*/_jsx(_Fragment, {\n    children: children(props, meta)\n  });\n}\nDropdownToggle.displayName = 'DropdownToggle';\n\n/** @component */\nexport default DropdownToggle;","const _excluded = [\"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\", \"addEndListener\", \"children\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport { cloneElement, useCallback, useRef } from 'react';\nimport useMergedRefs from '@restart/hooks/useMergedRefs';\nimport { getReactVersion } from './utils';\n/**\n * Normalizes RTG transition callbacks with nodeRef to better support\n * strict mode.\n *\n * @param props Transition props.\n * @returns Normalized transition props.\n */\nexport default function useRTGTransitionProps(_ref) {\n  let {\n      onEnter,\n      onEntering,\n      onEntered,\n      onExit,\n      onExiting,\n      onExited,\n      addEndListener,\n      children\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const {\n    major\n  } = getReactVersion();\n  const childRef = major >= 19 ? children.props.ref : children.ref;\n  const nodeRef = useRef(null);\n  const mergedRef = useMergedRefs(nodeRef, typeof children === 'function' ? null : childRef);\n  const normalize = callback => param => {\n    if (callback && nodeRef.current) {\n      callback(nodeRef.current, param);\n    }\n  };\n\n  /* eslint-disable react-hooks/exhaustive-deps */\n  const handleEnter = useCallback(normalize(onEnter), [onEnter]);\n  const handleEntering = useCallback(normalize(onEntering), [onEntering]);\n  const handleEntered = useCallback(normalize(onEntered), [onEntered]);\n  const handleExit = useCallback(normalize(onExit), [onExit]);\n  const handleExiting = useCallback(normalize(onExiting), [onExiting]);\n  const handleExited = useCallback(normalize(onExited), [onExited]);\n  const handleAddEndListener = useCallback(normalize(addEndListener), [addEndListener]);\n  /* eslint-enable react-hooks/exhaustive-deps */\n\n  return Object.assign({}, props, {\n    nodeRef\n  }, onEnter && {\n    onEnter: handleEnter\n  }, onEntering && {\n    onEntering: handleEntering\n  }, onEntered && {\n    onEntered: handleEntered\n  }, onExit && {\n    onExit: handleExit\n  }, onExiting && {\n    onExiting: handleExiting\n  }, onExited && {\n    onExited: handleExited\n  }, addEndListener && {\n    addEndListener: handleAddEndListener\n  }, {\n    children: typeof children === 'function' ? (status, innerProps) =>\n    // TODO: Types for RTG missing innerProps, so need to cast.\n    children(status, Object.assign({}, innerProps, {\n      ref: mergedRef\n    })) : /*#__PURE__*/cloneElement(children, {\n      ref: mergedRef\n    })\n  });\n}","const _excluded = [\"component\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport * as React from 'react';\nimport useRTGTransitionProps from './useRTGTransitionProps';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n// Normalizes Transition callbacks when nodeRef is used.\nconst RTGTransition = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n      component: Component\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const transitionProps = useRTGTransitionProps(props);\n  return /*#__PURE__*/_jsx(Component, Object.assign({\n    ref: ref\n  }, transitionProps));\n});\nexport default RTGTransition;","import useMergedRefs from '@restart/hooks/useMergedRefs';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport useIsomorphicEffect from '@restart/hooks/useIsomorphicEffect';\nimport React, { useRef, cloneElement, useState } from 'react';\nimport NoopTransition from './NoopTransition';\nimport RTGTransition from './RTGTransition';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function useTransition({\n  in: inProp,\n  onTransition\n}) {\n  const ref = useRef(null);\n  const isInitialRef = useRef(true);\n  const handleTransition = useEventCallback(onTransition);\n  useIsomorphicEffect(() => {\n    if (!ref.current) {\n      return undefined;\n    }\n    let stale = false;\n    handleTransition({\n      in: inProp,\n      element: ref.current,\n      initial: isInitialRef.current,\n      isStale: () => stale\n    });\n    return () => {\n      stale = true;\n    };\n  }, [inProp, handleTransition]);\n  useIsomorphicEffect(() => {\n    isInitialRef.current = false;\n    // this is for strict mode\n    return () => {\n      isInitialRef.current = true;\n    };\n  }, []);\n  return ref;\n}\n/**\n * Adapts an imperative transition function to a subset of the RTG `<Transition>` component API.\n *\n * ImperativeTransition does not support mounting options or `appear` at the moment, meaning\n * that it always acts like: `mountOnEnter={true} unmountOnExit={true} appear={true}`\n */\nexport default function ImperativeTransition({\n  children,\n  in: inProp,\n  onExited,\n  onEntered,\n  transition\n}) {\n  const [exited, setExited] = useState(!inProp);\n\n  // TODO: I think this needs to be in an effect\n  if (inProp && exited) {\n    setExited(false);\n  }\n  const ref = useTransition({\n    in: !!inProp,\n    onTransition: options => {\n      const onFinish = () => {\n        if (options.isStale()) return;\n        if (options.in) {\n          onEntered == null ? void 0 : onEntered(options.element, options.initial);\n        } else {\n          setExited(true);\n          onExited == null ? void 0 : onExited(options.element);\n        }\n      };\n      Promise.resolve(transition(options)).then(onFinish, error => {\n        if (!options.in) setExited(true);\n        throw error;\n      });\n    }\n  });\n  const combinedRef = useMergedRefs(ref, children.ref);\n  return exited && !inProp ? null : /*#__PURE__*/cloneElement(children, {\n    ref: combinedRef\n  });\n}\nexport function renderTransition(component, runTransition, props) {\n  if (component) {\n    return /*#__PURE__*/_jsx(RTGTransition, Object.assign({}, props, {\n      component: component\n    }));\n  }\n  if (runTransition) {\n    return /*#__PURE__*/_jsx(ImperativeTransition, Object.assign({}, props, {\n      transition: runTransition\n    }));\n  }\n  return /*#__PURE__*/_jsx(NoopTransition, Object.assign({}, props));\n}","const _excluded = [\"show\", \"role\", \"className\", \"style\", \"children\", \"backdrop\", \"keyboard\", \"onBackdropClick\", \"onEscapeKeyDown\", \"transition\", \"runTransition\", \"backdropTransition\", \"runBackdropTransition\", \"autoFocus\", \"enforceFocus\", \"restoreFocus\", \"restoreFocusOptions\", \"renderDialog\", \"renderBackdrop\", \"manager\", \"container\", \"onShow\", \"onHide\", \"onExit\", \"onExited\", \"onExiting\", \"onEnter\", \"onEntering\", \"onEntered\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* eslint-disable @typescript-eslint/no-use-before-define, react/prop-types */\n\nimport activeElement from 'dom-helpers/activeElement';\nimport contains from 'dom-helpers/contains';\nimport canUseDOM from 'dom-helpers/canUseDOM';\nimport listen from 'dom-helpers/listen';\nimport { useState, useRef, useCallback, useImperativeHandle, forwardRef, useEffect } from 'react';\nimport * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport useMounted from '@restart/hooks/useMounted';\nimport useWillUnmount from '@restart/hooks/useWillUnmount';\nimport usePrevious from '@restart/hooks/usePrevious';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport ModalManager from './ModalManager';\nimport useWaitForDOMRef from './useWaitForDOMRef';\nimport useWindow from './useWindow';\nimport { renderTransition } from './ImperativeTransition';\nimport { isEscKey } from './utils';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nlet manager;\nfunction getManager(window) {\n  if (!manager) manager = new ModalManager({\n    ownerDocument: window == null ? void 0 : window.document\n  });\n  return manager;\n}\nfunction useModalManager(provided) {\n  const window = useWindow();\n  const modalManager = provided || getManager(window);\n  const modal = useRef({\n    dialog: null,\n    backdrop: null\n  });\n  return Object.assign(modal.current, {\n    add: () => modalManager.add(modal.current),\n    remove: () => modalManager.remove(modal.current),\n    isTopModal: () => modalManager.isTopModal(modal.current),\n    setDialogRef: useCallback(ref => {\n      modal.current.dialog = ref;\n    }, []),\n    setBackdropRef: useCallback(ref => {\n      modal.current.backdrop = ref;\n    }, [])\n  });\n}\nconst Modal = /*#__PURE__*/forwardRef((_ref, ref) => {\n  let {\n      show = false,\n      role = 'dialog',\n      className,\n      style,\n      children,\n      backdrop = true,\n      keyboard = true,\n      onBackdropClick,\n      onEscapeKeyDown,\n      transition,\n      runTransition,\n      backdropTransition,\n      runBackdropTransition,\n      autoFocus = true,\n      enforceFocus = true,\n      restoreFocus = true,\n      restoreFocusOptions,\n      renderDialog,\n      renderBackdrop = props => /*#__PURE__*/_jsx(\"div\", Object.assign({}, props)),\n      manager: providedManager,\n      container: containerRef,\n      onShow,\n      onHide = () => {},\n      onExit,\n      onExited,\n      onExiting,\n      onEnter,\n      onEntering,\n      onEntered\n    } = _ref,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const ownerWindow = useWindow();\n  const container = useWaitForDOMRef(containerRef);\n  const modal = useModalManager(providedManager);\n  const isMounted = useMounted();\n  const prevShow = usePrevious(show);\n  const [exited, setExited] = useState(!show);\n  const lastFocusRef = useRef(null);\n  useImperativeHandle(ref, () => modal, [modal]);\n  if (canUseDOM && !prevShow && show) {\n    lastFocusRef.current = activeElement(ownerWindow == null ? void 0 : ownerWindow.document);\n  }\n\n  // TODO: I think this needs to be in an effect\n  if (show && exited) {\n    setExited(false);\n  }\n  const handleShow = useEventCallback(() => {\n    modal.add();\n    removeKeydownListenerRef.current = listen(document, 'keydown', handleDocumentKeyDown);\n    removeFocusListenerRef.current = listen(document, 'focus',\n    // the timeout is necessary b/c this will run before the new modal is mounted\n    // and so steals focus from it\n    () => setTimeout(handleEnforceFocus), true);\n    if (onShow) {\n      onShow();\n    }\n\n    // autofocus after onShow to not trigger a focus event for previous\n    // modals before this one is shown.\n    if (autoFocus) {\n      var _modal$dialog$ownerDo, _modal$dialog;\n      const currentActiveElement = activeElement((_modal$dialog$ownerDo = (_modal$dialog = modal.dialog) == null ? void 0 : _modal$dialog.ownerDocument) != null ? _modal$dialog$ownerDo : ownerWindow == null ? void 0 : ownerWindow.document);\n      if (modal.dialog && currentActiveElement && !contains(modal.dialog, currentActiveElement)) {\n        lastFocusRef.current = currentActiveElement;\n        modal.dialog.focus();\n      }\n    }\n  });\n  const handleHide = useEventCallback(() => {\n    modal.remove();\n    removeKeydownListenerRef.current == null ? void 0 : removeKeydownListenerRef.current();\n    removeFocusListenerRef.current == null ? void 0 : removeFocusListenerRef.current();\n    if (restoreFocus) {\n      var _lastFocusRef$current;\n      // Support: <=IE11 doesn't support `focus()` on svg elements (RB: #917)\n      (_lastFocusRef$current = lastFocusRef.current) == null ? void 0 : _lastFocusRef$current.focus == null ? void 0 : _lastFocusRef$current.focus(restoreFocusOptions);\n      lastFocusRef.current = null;\n    }\n  });\n\n  // TODO: try and combine these effects: https://github.com/react-bootstrap/react-overlays/pull/794#discussion_r409954120\n\n  // Show logic when:\n  //  - show is `true` _and_ `container` has resolved\n  useEffect(() => {\n    if (!show || !container) return;\n    handleShow();\n  }, [show, container, /* should never change: */handleShow]);\n\n  // Hide cleanup logic when:\n  //  - `exited` switches to true\n  //  - component unmounts;\n  useEffect(() => {\n    if (!exited) return;\n    handleHide();\n  }, [exited, handleHide]);\n  useWillUnmount(() => {\n    handleHide();\n  });\n\n  // --------------------------------\n\n  const handleEnforceFocus = useEventCallback(() => {\n    if (!enforceFocus || !isMounted() || !modal.isTopModal()) {\n      return;\n    }\n    const currentActiveElement = activeElement(ownerWindow == null ? void 0 : ownerWindow.document);\n    if (modal.dialog && currentActiveElement && !contains(modal.dialog, currentActiveElement)) {\n      modal.dialog.focus();\n    }\n  });\n  const handleBackdropClick = useEventCallback(e => {\n    if (e.target !== e.currentTarget) {\n      return;\n    }\n    onBackdropClick == null ? void 0 : onBackdropClick(e);\n    if (backdrop === true) {\n      onHide();\n    }\n  });\n  const handleDocumentKeyDown = useEventCallback(e => {\n    if (keyboard && isEscKey(e) && modal.isTopModal()) {\n      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(e);\n      if (!e.defaultPrevented) {\n        onHide();\n      }\n    }\n  });\n  const removeFocusListenerRef = useRef();\n  const removeKeydownListenerRef = useRef();\n  const handleHidden = (...args) => {\n    setExited(true);\n    onExited == null ? void 0 : onExited(...args);\n  };\n  if (!container) {\n    return null;\n  }\n  const dialogProps = Object.assign({\n    role,\n    ref: modal.setDialogRef,\n    // apparently only works on the dialog role element\n    'aria-modal': role === 'dialog' ? true : undefined\n  }, rest, {\n    style,\n    className,\n    tabIndex: -1\n  });\n  let dialog = renderDialog ? renderDialog(dialogProps) : /*#__PURE__*/_jsx(\"div\", Object.assign({}, dialogProps, {\n    children: /*#__PURE__*/React.cloneElement(children, {\n      role: 'document'\n    })\n  }));\n  dialog = renderTransition(transition, runTransition, {\n    unmountOnExit: true,\n    mountOnEnter: true,\n    appear: true,\n    in: !!show,\n    onExit,\n    onExiting,\n    onExited: handleHidden,\n    onEnter,\n    onEntering,\n    onEntered,\n    children: dialog\n  });\n  let backdropElement = null;\n  if (backdrop) {\n    backdropElement = renderBackdrop({\n      ref: modal.setBackdropRef,\n      onClick: handleBackdropClick\n    });\n    backdropElement = renderTransition(backdropTransition, runBackdropTransition, {\n      in: !!show,\n      appear: true,\n      mountOnEnter: true,\n      unmountOnExit: true,\n      children: backdropElement\n    });\n  }\n  return /*#__PURE__*/_jsx(_Fragment, {\n    children: /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_jsxs(_Fragment, {\n      children: [backdropElement, dialog]\n    }), container)\n  });\n});\nModal.displayName = 'Modal';\nexport default Object.assign(Modal, {\n  Manager: ModalManager\n});","import css from 'dom-helpers/css';\nimport { dataAttr } from './DataKey';\nimport getBodyScrollbarWidth from './getScrollbarWidth';\nexport const OPEN_DATA_ATTRIBUTE = dataAttr('modal-open');\n\n/**\n * Manages a stack of Modals as well as ensuring\n * body scrolling is is disabled and padding accounted for\n */\nclass ModalManager {\n  constructor({\n    ownerDocument,\n    handleContainerOverflow = true,\n    isRTL = false\n  } = {}) {\n    this.handleContainerOverflow = handleContainerOverflow;\n    this.isRTL = isRTL;\n    this.modals = [];\n    this.ownerDocument = ownerDocument;\n  }\n  getScrollbarWidth() {\n    return getBodyScrollbarWidth(this.ownerDocument);\n  }\n  getElement() {\n    return (this.ownerDocument || document).body;\n  }\n  setModalAttributes(_modal) {\n    // For overriding\n  }\n  removeModalAttributes(_modal) {\n    // For overriding\n  }\n  setContainerStyle(containerState) {\n    const style = {\n      overflow: 'hidden'\n    };\n\n    // we are only interested in the actual `style` here\n    // because we will override it\n    const paddingProp = this.isRTL ? 'paddingLeft' : 'paddingRight';\n    const container = this.getElement();\n    containerState.style = {\n      overflow: container.style.overflow,\n      [paddingProp]: container.style[paddingProp]\n    };\n    if (containerState.scrollBarWidth) {\n      // use computed style, here to get the real padding\n      // to add our scrollbar width\n      style[paddingProp] = `${parseInt(css(container, paddingProp) || '0', 10) + containerState.scrollBarWidth}px`;\n    }\n    container.setAttribute(OPEN_DATA_ATTRIBUTE, '');\n    css(container, style);\n  }\n  reset() {\n    [...this.modals].forEach(m => this.remove(m));\n  }\n  removeContainerStyle(containerState) {\n    const container = this.getElement();\n    container.removeAttribute(OPEN_DATA_ATTRIBUTE);\n    Object.assign(container.style, containerState.style);\n  }\n  add(modal) {\n    let modalIdx = this.modals.indexOf(modal);\n    if (modalIdx !== -1) {\n      return modalIdx;\n    }\n    modalIdx = this.modals.length;\n    this.modals.push(modal);\n    this.setModalAttributes(modal);\n    if (modalIdx !== 0) {\n      return modalIdx;\n    }\n    this.state = {\n      scrollBarWidth: this.getScrollbarWidth(),\n      style: {}\n    };\n    if (this.handleContainerOverflow) {\n      this.setContainerStyle(this.state);\n    }\n    return modalIdx;\n  }\n  remove(modal) {\n    const modalIdx = this.modals.indexOf(modal);\n    if (modalIdx === -1) {\n      return;\n    }\n    this.modals.splice(modalIdx, 1);\n\n    // if that was the last modal in a container,\n    // clean up the container\n    if (!this.modals.length && this.handleContainerOverflow) {\n      this.removeContainerStyle(this.state);\n    }\n    this.removeModalAttributes(modal);\n  }\n  isTopModal(modal) {\n    return !!this.modals.length && this.modals[this.modals.length - 1] === modal;\n  }\n}\nexport default ModalManager;","/**\n * Get the width of the vertical window scrollbar if it's visible\n */\nexport default function getBodyScrollbarWidth(ownerDocument = document) {\n  const window = ownerDocument.defaultView;\n  return Math.abs(window.innerWidth - ownerDocument.documentElement.clientWidth);\n}","const _excluded = [\"as\", \"onSelect\", \"activeKey\", \"role\", \"onKeyDown\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport qsa from 'dom-helpers/querySelectorAll';\nimport * as React from 'react';\nimport { useContext, useEffect, useRef } from 'react';\nimport useForceUpdate from '@restart/hooks/useForceUpdate';\nimport useMergedRefs from '@restart/hooks/useMergedRefs';\nimport NavContext from './NavContext';\nimport SelectableContext, { makeEventKey } from './SelectableContext';\nimport TabContext from './TabContext';\nimport { dataAttr, dataProp } from './DataKey';\nimport NavItem from './NavItem';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {};\nconst EVENT_KEY_ATTR = dataAttr('event-key');\nconst Nav = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n      // Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n      as: Component = 'div',\n      onSelect,\n      activeKey,\n      role,\n      onKeyDown\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  // A ref and forceUpdate for refocus, b/c we only want to trigger when needed\n  // and don't want to reset the set in the effect\n  const forceUpdate = useForceUpdate();\n  const needsRefocusRef = useRef(false);\n  const parentOnSelect = useContext(SelectableContext);\n  const tabContext = useContext(TabContext);\n  let getControlledId, getControllerId;\n  if (tabContext) {\n    role = role || 'tablist';\n    activeKey = tabContext.activeKey;\n    // TODO: do we need to duplicate these?\n    getControlledId = tabContext.getControlledId;\n    getControllerId = tabContext.getControllerId;\n  }\n  const listNode = useRef(null);\n  const getNextActiveTab = offset => {\n    const currentListNode = listNode.current;\n    if (!currentListNode) return null;\n    const items = qsa(currentListNode, `[${EVENT_KEY_ATTR}]:not([aria-disabled=true])`);\n    const activeChild = currentListNode.querySelector('[aria-selected=true]');\n    if (!activeChild || activeChild !== document.activeElement) return null;\n    const index = items.indexOf(activeChild);\n    if (index === -1) return null;\n    let nextIndex = index + offset;\n    if (nextIndex >= items.length) nextIndex = 0;\n    if (nextIndex < 0) nextIndex = items.length - 1;\n    return items[nextIndex];\n  };\n  const handleSelect = (key, event) => {\n    if (key == null) return;\n    onSelect == null ? void 0 : onSelect(key, event);\n    parentOnSelect == null ? void 0 : parentOnSelect(key, event);\n  };\n  const handleKeyDown = event => {\n    onKeyDown == null ? void 0 : onKeyDown(event);\n    if (!tabContext) {\n      return;\n    }\n    let nextActiveChild;\n    switch (event.key) {\n      case 'ArrowLeft':\n      case 'ArrowUp':\n        nextActiveChild = getNextActiveTab(-1);\n        break;\n      case 'ArrowRight':\n      case 'ArrowDown':\n        nextActiveChild = getNextActiveTab(1);\n        break;\n      default:\n        return;\n    }\n    if (!nextActiveChild) return;\n    event.preventDefault();\n    handleSelect(nextActiveChild.dataset[dataProp('EventKey')] || null, event);\n    needsRefocusRef.current = true;\n    forceUpdate();\n  };\n  useEffect(() => {\n    if (listNode.current && needsRefocusRef.current) {\n      const activeChild = listNode.current.querySelector(`[${EVENT_KEY_ATTR}][aria-selected=true]`);\n      activeChild == null ? void 0 : activeChild.focus();\n    }\n    needsRefocusRef.current = false;\n  });\n  const mergedRef = useMergedRefs(ref, listNode);\n  return /*#__PURE__*/_jsx(SelectableContext.Provider, {\n    value: handleSelect,\n    children: /*#__PURE__*/_jsx(NavContext.Provider, {\n      value: {\n        role,\n        // used by NavLink to determine it's role\n        activeKey: makeEventKey(activeKey),\n        getControlledId: getControlledId || noop,\n        getControllerId: getControllerId || noop\n      },\n      children: /*#__PURE__*/_jsx(Component, Object.assign({}, props, {\n        onKeyDown: handleKeyDown,\n        ref: mergedRef,\n        role: role\n      }))\n    })\n  });\n});\nNav.displayName = 'Nav';\nexport default Object.assign(Nav, {\n  Item: NavItem\n});","import * as React from 'react';\nconst NavContext = /*#__PURE__*/React.createContext(null);\nNavContext.displayName = 'NavContext';\nexport default NavContext;","const _excluded = [\"as\", \"active\", \"eventKey\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport * as React from 'react';\nimport { useContext } from 'react';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport NavContext from './NavContext';\nimport SelectableContext, { makeEventKey } from './SelectableContext';\nimport Button from './Button';\nimport { dataAttr } from './DataKey';\nimport TabContext from './TabContext';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function useNavItem({\n  key,\n  onClick,\n  active,\n  id,\n  role,\n  disabled\n}) {\n  const parentOnSelect = useContext(SelectableContext);\n  const navContext = useContext(NavContext);\n  const tabContext = useContext(TabContext);\n  let isActive = active;\n  const props = {\n    role\n  };\n  if (navContext) {\n    if (!role && navContext.role === 'tablist') props.role = 'tab';\n    const contextControllerId = navContext.getControllerId(key != null ? key : null);\n    const contextControlledId = navContext.getControlledId(key != null ? key : null);\n\n    // @ts-ignore\n    props[dataAttr('event-key')] = key;\n    props.id = contextControllerId || id;\n    isActive = active == null && key != null ? navContext.activeKey === key : active;\n\n    /**\n     * Simplified scenario for `mountOnEnter`.\n     *\n     * While it would make sense to keep 'aria-controls' for tabs that have been mounted at least\n     * once, it would also complicate the code quite a bit, for very little gain.\n     * The following implementation is probably good enough.\n     *\n     * @see https://github.com/react-restart/ui/pull/40#issuecomment-1009971561\n     */\n    if (isActive || !(tabContext != null && tabContext.unmountOnExit) && !(tabContext != null && tabContext.mountOnEnter)) props['aria-controls'] = contextControlledId;\n  }\n  if (props.role === 'tab') {\n    props['aria-selected'] = isActive;\n    if (!isActive) {\n      props.tabIndex = -1;\n    }\n    if (disabled) {\n      props.tabIndex = -1;\n      props['aria-disabled'] = true;\n    }\n  }\n  props.onClick = useEventCallback(e => {\n    if (disabled) return;\n    onClick == null ? void 0 : onClick(e);\n    if (key == null) {\n      return;\n    }\n    if (parentOnSelect && !e.isPropagationStopped()) {\n      parentOnSelect(key, e);\n    }\n  });\n  return [props, {\n    isActive\n  }];\n}\nconst NavItem = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n      as: Component = Button,\n      active,\n      eventKey\n    } = _ref,\n    options = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const [props, meta] = useNavItem(Object.assign({\n    key: makeEventKey(eventKey, options.href),\n    active\n  }, options));\n\n  // @ts-ignore\n  props[dataAttr('active')] = meta.isActive;\n  return /*#__PURE__*/_jsx(Component, Object.assign({}, options, props, {\n    ref: ref\n  }));\n});\nNavItem.displayName = 'NavItem';\nexport default NavItem;","import useEventCallback from '@restart/hooks/useEventCallback';\nimport useMergedRefs from '@restart/hooks/useMergedRefs';\nimport { cloneElement, useEffect, useRef } from 'react';\nfunction NoopTransition({\n  children,\n  in: inProp,\n  onExited,\n  mountOnEnter,\n  unmountOnExit\n}) {\n  const ref = useRef(null);\n  const hasEnteredRef = useRef(inProp);\n  const handleExited = useEventCallback(onExited);\n  useEffect(() => {\n    if (inProp) hasEnteredRef.current = true;else {\n      handleExited(ref.current);\n    }\n  }, [inProp, handleExited]);\n  const combinedRef = useMergedRefs(ref, children.ref);\n  const child = /*#__PURE__*/cloneElement(children, {\n    ref: combinedRef\n  });\n  if (inProp) return child;\n  if (unmountOnExit) {\n    return null;\n  }\n  if (!hasEnteredRef.current && mountOnEnter) {\n    return null;\n  }\n  return child;\n}\nexport default NoopTransition;","import listen from 'dom-helpers/listen';\nimport ownerDocument from 'dom-helpers/ownerDocument';\nimport { useEffect } from 'react';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport useClickOutside, { getRefTarget } from './useClickOutside';\nimport { isEscKey } from './utils';\nconst noop = () => {};\n/**\n * The `useRootClose` hook registers your callback on the document\n * when rendered. Powers the `<Overlay/>` component. This is used achieve modal\n * style behavior where your callback is triggered when the user tries to\n * interact with the rest of the document or hits the `esc` key.\n *\n * @param {Ref<HTMLElement>| HTMLElement} ref  The element boundary\n * @param {function} onRootClose\n * @param {object=}  options\n * @param {boolean=} options.disabled\n * @param {string=}  options.clickTrigger The DOM event name (click, mousedown, etc) to attach listeners on\n */\nfunction useRootClose(ref, onRootClose, {\n  disabled,\n  clickTrigger\n} = {}) {\n  const onClose = onRootClose || noop;\n  useClickOutside(ref, onClose, {\n    disabled,\n    clickTrigger\n  });\n  const handleKeyUp = useEventCallback(e => {\n    if (isEscKey(e)) {\n      onClose(e);\n    }\n  });\n  useEffect(() => {\n    if (disabled || ref == null) return undefined;\n    const doc = ownerDocument(getRefTarget(ref));\n\n    // Store the current event to avoid triggering handlers immediately\n    // https://github.com/facebook/react/issues/20074\n    let currentEvent = (doc.defaultView || window).event;\n    const removeKeyupListener = listen(doc, 'keyup', e => {\n      // skip if this event is the same as the one running when we added the handlers\n      if (e === currentEvent) {\n        currentEvent = undefined;\n        return;\n      }\n      handleKeyUp(e);\n    });\n    return () => {\n      removeKeyupListener();\n    };\n  }, [ref, disabled, handleKeyUp]);\n}\nexport default useRootClose;","import * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport useCallbackRef from '@restart/hooks/useCallbackRef';\nimport useMergedRefs from '@restart/hooks/useMergedRefs';\nimport { useState } from 'react';\nimport usePopper from './usePopper';\nimport useRootClose from './useRootClose';\nimport useWaitForDOMRef from './useWaitForDOMRef';\nimport mergeOptionsWithPopperConfig from './mergeOptionsWithPopperConfig';\nimport { renderTransition } from './ImperativeTransition';\n/**\n * Built on top of `Popper.js`, the overlay component is\n * great for custom tooltip overlays.\n */\nconst Overlay = /*#__PURE__*/React.forwardRef((props, outerRef) => {\n  const {\n    flip,\n    offset,\n    placement,\n    containerPadding,\n    popperConfig = {},\n    transition: Transition,\n    runTransition\n  } = props;\n  const [rootElement, attachRef] = useCallbackRef();\n  const [arrowElement, attachArrowRef] = useCallbackRef();\n  const mergedRef = useMergedRefs(attachRef, outerRef);\n  const container = useWaitForDOMRef(props.container);\n  const target = useWaitForDOMRef(props.target);\n  const [exited, setExited] = useState(!props.show);\n  const popper = usePopper(target, rootElement, mergeOptionsWithPopperConfig({\n    placement,\n    enableEvents: !!props.show,\n    containerPadding: containerPadding || 5,\n    flip,\n    offset,\n    arrowElement,\n    popperConfig\n  }));\n\n  // TODO: I think this needs to be in an effect\n  if (props.show && exited) {\n    setExited(false);\n  }\n  const handleHidden = (...args) => {\n    setExited(true);\n    if (props.onExited) {\n      props.onExited(...args);\n    }\n  };\n\n  // Don't un-render the overlay while it's transitioning out.\n  const mountOverlay = props.show || !exited;\n  useRootClose(rootElement, props.onHide, {\n    disabled: !props.rootClose || props.rootCloseDisabled,\n    clickTrigger: props.rootCloseEvent\n  });\n  if (!mountOverlay) {\n    // Don't bother showing anything if we don't have to.\n    return null;\n  }\n  const {\n    onExit,\n    onExiting,\n    onEnter,\n    onEntering,\n    onEntered\n  } = props;\n  let child = props.children(Object.assign({}, popper.attributes.popper, {\n    style: popper.styles.popper,\n    ref: mergedRef\n  }), {\n    popper,\n    placement,\n    show: !!props.show,\n    arrowProps: Object.assign({}, popper.attributes.arrow, {\n      style: popper.styles.arrow,\n      ref: attachArrowRef\n    })\n  });\n  child = renderTransition(Transition, runTransition, {\n    in: !!props.show,\n    appear: true,\n    mountOnEnter: true,\n    unmountOnExit: true,\n    children: child,\n    onExit,\n    onExiting,\n    onExited: handleHidden,\n    onEnter,\n    onEntering,\n    onEntered\n  });\n  return container ? /*#__PURE__*/ReactDOM.createPortal(child, container) : null;\n});\nOverlay.displayName = 'Overlay';\nexport default Overlay;","import * as React from 'react';\nconst SelectableContext = /*#__PURE__*/React.createContext(null);\nexport const makeEventKey = (eventKey, href = null) => {\n  if (eventKey != null) return String(eventKey);\n  return href || null;\n};\nexport default SelectableContext;","import * as React from 'react';\nconst TabContext = /*#__PURE__*/React.createContext(null);\nexport default TabContext;","const _excluded = [\"active\", \"eventKey\", \"mountOnEnter\", \"transition\", \"unmountOnExit\", \"role\", \"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\"],\n  _excluded2 = [\"activeKey\", \"getControlledId\", \"getControllerId\"],\n  _excluded3 = [\"as\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport * as React from 'react';\nimport { useContext } from 'react';\nimport TabContext from './TabContext';\nimport SelectableContext, { makeEventKey } from './SelectableContext';\nimport NoopTransition from './NoopTransition';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function useTabPanel(_ref) {\n  let {\n      active,\n      eventKey,\n      mountOnEnter,\n      transition,\n      unmountOnExit,\n      role = 'tabpanel',\n      onEnter,\n      onEntering,\n      onEntered,\n      onExit,\n      onExiting,\n      onExited\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const context = useContext(TabContext);\n  if (!context) return [Object.assign({}, props, {\n    role\n  }), {\n    eventKey,\n    isActive: active,\n    mountOnEnter,\n    transition,\n    unmountOnExit,\n    onEnter,\n    onEntering,\n    onEntered,\n    onExit,\n    onExiting,\n    onExited\n  }];\n  const {\n      activeKey,\n      getControlledId,\n      getControllerId\n    } = context,\n    rest = _objectWithoutPropertiesLoose(context, _excluded2);\n  const key = makeEventKey(eventKey);\n  return [Object.assign({}, props, {\n    role,\n    id: getControlledId(eventKey),\n    'aria-labelledby': getControllerId(eventKey)\n  }), {\n    eventKey,\n    isActive: active == null && key != null ? makeEventKey(activeKey) === key : active,\n    transition: transition || rest.transition,\n    mountOnEnter: mountOnEnter != null ? mountOnEnter : rest.mountOnEnter,\n    unmountOnExit: unmountOnExit != null ? unmountOnExit : rest.unmountOnExit,\n    onEnter,\n    onEntering,\n    onEntered,\n    onExit,\n    onExiting,\n    onExited\n  }];\n}\nconst TabPanel = /*#__PURE__*/React.forwardRef(\n// Need to define the default \"as\" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595\n(_ref2, ref) => {\n  let {\n      as: Component = 'div'\n    } = _ref2,\n    props = _objectWithoutPropertiesLoose(_ref2, _excluded3);\n  const [tabPanelProps, {\n    isActive,\n    onEnter,\n    onEntering,\n    onEntered,\n    onExit,\n    onExiting,\n    onExited,\n    mountOnEnter,\n    unmountOnExit,\n    transition: Transition = NoopTransition\n  }] = useTabPanel(props);\n  // We provide an empty the TabContext so `<Nav>`s in `<TabPanel>`s don't\n  // conflict with the top level one.\n  return /*#__PURE__*/_jsx(TabContext.Provider, {\n    value: null,\n    children: /*#__PURE__*/_jsx(SelectableContext.Provider, {\n      value: null,\n      children: /*#__PURE__*/_jsx(Transition, {\n        in: isActive,\n        onEnter: onEnter,\n        onEntering: onEntering,\n        onEntered: onEntered,\n        onExit: onExit,\n        onExiting: onExiting,\n        onExited: onExited,\n        mountOnEnter: mountOnEnter,\n        unmountOnExit: unmountOnExit,\n        children: /*#__PURE__*/_jsx(Component, Object.assign({}, tabPanelProps, {\n          ref: ref,\n          hidden: !isActive,\n          \"aria-hidden\": !isActive\n        }))\n      })\n    })\n  });\n});\nTabPanel.displayName = 'TabPanel';\nexport default TabPanel;","import * as React from 'react';\nimport { useMemo } from 'react';\nimport { useUncontrolledProp } from 'uncontrollable';\nimport { useSSRSafeId } from './ssr';\nimport TabContext from './TabContext';\nimport SelectableContext from './SelectableContext';\nimport TabPanel from './TabPanel';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst Tabs = props => {\n  const {\n    id: userId,\n    generateChildId: generateCustomChildId,\n    onSelect: propsOnSelect,\n    activeKey: propsActiveKey,\n    defaultActiveKey,\n    transition,\n    mountOnEnter,\n    unmountOnExit,\n    children\n  } = props;\n  const [activeKey, onSelect] = useUncontrolledProp(propsActiveKey, defaultActiveKey, propsOnSelect);\n  const id = useSSRSafeId(userId);\n  const generateChildId = useMemo(() => generateCustomChildId || ((key, type) => id ? `${id}-${type}-${key}` : null), [id, generateCustomChildId]);\n  const tabContext = useMemo(() => ({\n    onSelect,\n    activeKey,\n    transition,\n    mountOnEnter: mountOnEnter || false,\n    unmountOnExit: unmountOnExit || false,\n    getControlledId: key => generateChildId(key, 'tabpane'),\n    getControllerId: key => generateChildId(key, 'tab')\n  }), [onSelect, activeKey, transition, mountOnEnter, unmountOnExit, generateChildId]);\n  return /*#__PURE__*/_jsx(TabContext.Provider, {\n    value: tabContext,\n    children: /*#__PURE__*/_jsx(SelectableContext.Provider, {\n      value: onSelect || null,\n      children: children\n    })\n  });\n};\nTabs.Panel = TabPanel;\nexport default Tabs;","export function toModifierMap(modifiers) {\n  const result = {};\n  if (!Array.isArray(modifiers)) {\n    return modifiers || result;\n  }\n\n  // eslint-disable-next-line no-unused-expressions\n  modifiers == null ? void 0 : modifiers.forEach(m => {\n    result[m.name] = m;\n  });\n  return result;\n}\nexport function toModifierArray(map = {}) {\n  if (Array.isArray(map)) return map;\n  return Object.keys(map).map(k => {\n    map[k].name = k;\n    return map[k];\n  });\n}\nexport default function mergeOptionsWithPopperConfig({\n  enabled,\n  enableEvents,\n  placement,\n  flip,\n  offset,\n  fixed,\n  containerPadding,\n  arrowElement,\n  popperConfig = {}\n}) {\n  var _modifiers$eventListe, _modifiers$preventOve, _modifiers$preventOve2, _modifiers$offset, _modifiers$arrow;\n  const modifiers = toModifierMap(popperConfig.modifiers);\n  return Object.assign({}, popperConfig, {\n    placement,\n    enabled,\n    strategy: fixed ? 'fixed' : popperConfig.strategy,\n    modifiers: toModifierArray(Object.assign({}, modifiers, {\n      eventListeners: {\n        enabled: enableEvents,\n        options: (_modifiers$eventListe = modifiers.eventListeners) == null ? void 0 : _modifiers$eventListe.options\n      },\n      preventOverflow: Object.assign({}, modifiers.preventOverflow, {\n        options: containerPadding ? Object.assign({\n          padding: containerPadding\n        }, (_modifiers$preventOve = modifiers.preventOverflow) == null ? void 0 : _modifiers$preventOve.options) : (_modifiers$preventOve2 = modifiers.preventOverflow) == null ? void 0 : _modifiers$preventOve2.options\n      }),\n      offset: {\n        options: Object.assign({\n          offset\n        }, (_modifiers$offset = modifiers.offset) == null ? void 0 : _modifiers$offset.options)\n      },\n      arrow: Object.assign({}, modifiers.arrow, {\n        enabled: !!arrowElement,\n        options: Object.assign({}, (_modifiers$arrow = modifiers.arrow) == null ? void 0 : _modifiers$arrow.options, {\n          element: arrowElement\n        })\n      }),\n      flip: Object.assign({\n        enabled: !!flip\n      }, modifiers.flip)\n    }))\n  });\n}","import contains from 'dom-helpers/contains';\nimport listen from 'dom-helpers/listen';\nimport ownerDocument from 'dom-helpers/ownerDocument';\nimport { useCallback, useEffect, useRef } from 'react';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport warning from 'warning';\nconst noop = () => {};\nfunction isLeftClickEvent(event) {\n  return event.button === 0;\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nexport const getRefTarget = ref => ref && ('current' in ref ? ref.current : ref);\nconst InitialTriggerEvents = {\n  click: 'mousedown',\n  mouseup: 'mousedown',\n  pointerup: 'pointerdown'\n};\n\n/**\n * The `useClickOutside` hook registers your callback on the document that fires\n * when a pointer event is registered outside of the provided ref or element.\n *\n * @param {Ref<HTMLElement>| HTMLElement} ref  The element boundary\n * @param {function} onClickOutside\n * @param {object=}  options\n * @param {boolean=} options.disabled\n * @param {string=}  options.clickTrigger The DOM event name (click, mousedown, etc) to attach listeners on\n */\nfunction useClickOutside(ref, onClickOutside = noop, {\n  disabled,\n  clickTrigger = 'click'\n} = {}) {\n  const preventMouseClickOutsideRef = useRef(false);\n  const waitingForTrigger = useRef(false);\n  const handleMouseCapture = useCallback(e => {\n    const currentTarget = getRefTarget(ref);\n    warning(!!currentTarget, 'ClickOutside captured a close event but does not have a ref to compare it to. ' + 'useClickOutside(), should be passed a ref that resolves to a DOM node');\n    preventMouseClickOutsideRef.current = !currentTarget || isModifiedEvent(e) || !isLeftClickEvent(e) || !!contains(currentTarget, e.target) || waitingForTrigger.current;\n    waitingForTrigger.current = false;\n  }, [ref]);\n  const handleInitialMouse = useEventCallback(e => {\n    const currentTarget = getRefTarget(ref);\n    if (currentTarget && contains(currentTarget, e.target)) {\n      waitingForTrigger.current = true;\n    }\n  });\n  const handleMouse = useEventCallback(e => {\n    if (!preventMouseClickOutsideRef.current) {\n      onClickOutside(e);\n    }\n  });\n  useEffect(() => {\n    var _ownerWindow$event, _ownerWindow$parent;\n    if (disabled || ref == null) return undefined;\n    const doc = ownerDocument(getRefTarget(ref));\n    const ownerWindow = doc.defaultView || window;\n\n    // Store the current event to avoid triggering handlers immediately\n    // For things rendered in an iframe, the event might originate on the parent window\n    // so we should fall back to that global event if the local one doesn't exist\n    // https://github.com/facebook/react/issues/20074\n    let currentEvent = (_ownerWindow$event = ownerWindow.event) != null ? _ownerWindow$event : (_ownerWindow$parent = ownerWindow.parent) == null ? void 0 : _ownerWindow$parent.event;\n    let removeInitialTriggerListener = null;\n    if (InitialTriggerEvents[clickTrigger]) {\n      removeInitialTriggerListener = listen(doc, InitialTriggerEvents[clickTrigger], handleInitialMouse, true);\n    }\n\n    // Use capture for this listener so it fires before React's listener, to\n    // avoid false positives in the contains() check below if the target DOM\n    // element is removed in the React mouse callback.\n    const removeMouseCaptureListener = listen(doc, clickTrigger, handleMouseCapture, true);\n    const removeMouseListener = listen(doc, clickTrigger, e => {\n      // skip if this event is the same as the one running when we added the handlers\n      if (e === currentEvent) {\n        currentEvent = undefined;\n        return;\n      }\n      handleMouse(e);\n    });\n    let mobileSafariHackListeners = [];\n    if ('ontouchstart' in doc.documentElement) {\n      mobileSafariHackListeners = [].slice.call(doc.body.children).map(el => listen(el, 'mousemove', noop));\n    }\n    return () => {\n      removeInitialTriggerListener == null ? void 0 : removeInitialTriggerListener();\n      removeMouseCaptureListener();\n      removeMouseListener();\n      mobileSafariHackListeners.forEach(remove => remove());\n    };\n  }, [ref, disabled, clickTrigger, handleMouseCapture, handleInitialMouse, handleMouse]);\n}\nexport default useClickOutside;","import { useCallback } from 'react';\nimport useMounted from './useMounted';\n\n/**\n * `useSafeState` takes the return value of a `useState` hook and wraps the\n * setter to prevent updates onces the component has unmounted. Can used\n * with `useMergeState` and `useStateAsync` as well\n *\n * @param state The return value of a useStateHook\n *\n * ```ts\n * const [show, setShow] = useSafeState(useState(true));\n * ```\n */\n\nfunction useSafeState(state) {\n  const isMounted = useMounted();\n  return [state[0], useCallback(nextState => {\n    if (!isMounted()) return;\n    return state[1](nextState);\n  }, [isMounted, state[1]])];\n}\nexport default useSafeState;","import arrow from '@popperjs/core/lib/modifiers/arrow';\nimport computeStyles from '@popperjs/core/lib/modifiers/computeStyles';\nimport eventListeners from '@popperjs/core/lib/modifiers/eventListeners';\nimport flip from '@popperjs/core/lib/modifiers/flip';\nimport hide from '@popperjs/core/lib/modifiers/hide';\nimport offset from '@popperjs/core/lib/modifiers/offset';\nimport popperOffsets from '@popperjs/core/lib/modifiers/popperOffsets';\nimport preventOverflow from '@popperjs/core/lib/modifiers/preventOverflow';\nimport { placements } from '@popperjs/core/lib/enums';\nimport { popperGenerator } from '@popperjs/core/lib/popper-base';\n\n// For the common JS build we will turn this file into a bundle with no imports.\n// This is b/c the Popper lib is all esm files, and would break in a common js only environment\nexport const createPopper = popperGenerator({\n  defaultModifiers: [hide, popperOffsets, computeStyles, eventListeners, offset, flip, preventOverflow, arrow]\n});\nexport { placements };","const _excluded = [\"enabled\", \"placement\", \"strategy\", \"modifiers\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { dequal } from 'dequal';\nimport useSafeState from '@restart/hooks/useSafeState';\nimport { createPopper } from './popper';\nconst disabledApplyStylesModifier = {\n  name: 'applyStyles',\n  enabled: false,\n  phase: 'afterWrite',\n  fn: () => undefined\n};\n\n// until docjs supports type exports...\n\nconst ariaDescribedByModifier = {\n  name: 'ariaDescribedBy',\n  enabled: true,\n  phase: 'afterWrite',\n  effect: ({\n    state\n  }) => () => {\n    const {\n      reference,\n      popper\n    } = state.elements;\n    if ('removeAttribute' in reference) {\n      const ids = (reference.getAttribute('aria-describedby') || '').split(',').filter(id => id.trim() !== popper.id);\n      if (!ids.length) reference.removeAttribute('aria-describedby');else reference.setAttribute('aria-describedby', ids.join(','));\n    }\n  },\n  fn: ({\n    state\n  }) => {\n    var _popper$getAttribute;\n    const {\n      popper,\n      reference\n    } = state.elements;\n    const role = (_popper$getAttribute = popper.getAttribute('role')) == null ? void 0 : _popper$getAttribute.toLowerCase();\n    if (popper.id && role === 'tooltip' && 'setAttribute' in reference) {\n      const ids = reference.getAttribute('aria-describedby');\n      if (ids && ids.split(',').indexOf(popper.id) !== -1) {\n        return;\n      }\n      reference.setAttribute('aria-describedby', ids ? `${ids},${popper.id}` : popper.id);\n    }\n  }\n};\nconst EMPTY_MODIFIERS = [];\n/**\n * Position an element relative some reference element using Popper.js\n *\n * @param referenceElement\n * @param popperElement\n * @param {object}      options\n * @param {object=}     options.modifiers Popper.js modifiers\n * @param {boolean=}    options.enabled toggle the popper functionality on/off\n * @param {string=}     options.placement The popper element placement relative to the reference element\n * @param {string=}     options.strategy the positioning strategy\n * @param {function=}   options.onCreate called when the popper is created\n * @param {function=}   options.onUpdate called when the popper is updated\n *\n * @returns {UsePopperState} The popper state\n */\nfunction usePopper(referenceElement, popperElement, _ref = {}) {\n  let {\n      enabled = true,\n      placement = 'bottom',\n      strategy = 'absolute',\n      modifiers = EMPTY_MODIFIERS\n    } = _ref,\n    config = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const prevModifiers = useRef(modifiers);\n  const popperInstanceRef = useRef();\n  const update = useCallback(() => {\n    var _popperInstanceRef$cu;\n    (_popperInstanceRef$cu = popperInstanceRef.current) == null ? void 0 : _popperInstanceRef$cu.update();\n  }, []);\n  const forceUpdate = useCallback(() => {\n    var _popperInstanceRef$cu2;\n    (_popperInstanceRef$cu2 = popperInstanceRef.current) == null ? void 0 : _popperInstanceRef$cu2.forceUpdate();\n  }, []);\n  const [popperState, setState] = useSafeState(useState({\n    placement,\n    update,\n    forceUpdate,\n    attributes: {},\n    styles: {\n      popper: {},\n      arrow: {}\n    }\n  }));\n  const updateModifier = useMemo(() => ({\n    name: 'updateStateModifier',\n    enabled: true,\n    phase: 'write',\n    requires: ['computeStyles'],\n    fn: ({\n      state\n    }) => {\n      const styles = {};\n      const attributes = {};\n      Object.keys(state.elements).forEach(element => {\n        styles[element] = state.styles[element];\n        attributes[element] = state.attributes[element];\n      });\n      setState({\n        state,\n        styles,\n        attributes,\n        update,\n        forceUpdate,\n        placement: state.placement\n      });\n    }\n  }), [update, forceUpdate, setState]);\n  const nextModifiers = useMemo(() => {\n    if (!dequal(prevModifiers.current, modifiers)) {\n      prevModifiers.current = modifiers;\n    }\n    return prevModifiers.current;\n  }, [modifiers]);\n  useEffect(() => {\n    if (!popperInstanceRef.current || !enabled) return;\n    popperInstanceRef.current.setOptions({\n      placement,\n      strategy,\n      modifiers: [...nextModifiers, updateModifier, disabledApplyStylesModifier]\n    });\n  }, [strategy, placement, updateModifier, enabled, nextModifiers]);\n  useEffect(() => {\n    if (!enabled || referenceElement == null || popperElement == null) {\n      return undefined;\n    }\n    popperInstanceRef.current = createPopper(referenceElement, popperElement, Object.assign({}, config, {\n      placement,\n      strategy,\n      modifiers: [...nextModifiers, ariaDescribedByModifier, updateModifier]\n    }));\n    return () => {\n      if (popperInstanceRef.current != null) {\n        popperInstanceRef.current.destroy();\n        popperInstanceRef.current = undefined;\n        setState(s => Object.assign({}, s, {\n          attributes: {},\n          styles: {\n            popper: {}\n          }\n        }));\n      }\n    };\n    // This is only run once to _create_ the popper\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [enabled, referenceElement, popperElement]);\n  return popperState;\n}\nexport default usePopper;","import ownerDocument from 'dom-helpers/ownerDocument';\nimport canUseDOM from 'dom-helpers/canUseDOM';\nimport { useState, useEffect } from 'react';\nimport useWindow from './useWindow';\nexport const resolveContainerRef = (ref, document) => {\n  if (!canUseDOM) return null;\n  if (ref == null) return (document || ownerDocument()).body;\n  if (typeof ref === 'function') ref = ref();\n  if (ref && 'current' in ref) ref = ref.current;\n  if (ref && ('nodeType' in ref || ref.getBoundingClientRect)) return ref;\n  return null;\n};\nexport default function useWaitForDOMRef(ref, onResolved) {\n  const window = useWindow();\n  const [resolvedRef, setRef] = useState(() => resolveContainerRef(ref, window == null ? void 0 : window.document));\n  if (!resolvedRef) {\n    const earlyRef = resolveContainerRef(ref);\n    if (earlyRef) setRef(earlyRef);\n  }\n  useEffect(() => {\n    if (onResolved && resolvedRef) {\n      onResolved(resolvedRef);\n    }\n  }, [onResolved, resolvedRef]);\n  useEffect(() => {\n    const nextRef = resolveContainerRef(ref);\n    if (nextRef !== resolvedRef) {\n      setRef(nextRef);\n    }\n  }, [ref, resolvedRef]);\n  return resolvedRef;\n}","import { createContext, useContext } from 'react';\nimport canUseDOM from 'dom-helpers/canUseDOM';\nconst Context = /*#__PURE__*/createContext(canUseDOM ? window : undefined);\nexport const WindowProvider = Context.Provider;\n\n/**\n * The document \"window\" placed in React context. Helpful for determining\n * SSR context, or when rendering into an iframe.\n *\n * @returns the current window\n */\nexport default function useWindow() {\n  return useContext(Context);\n}","import * as React from 'react';\nexport function isEscKey(e) {\n  return e.code === 'Escape' || e.keyCode === 27;\n}\nexport function getReactVersion() {\n  const parts = React.version.split('.');\n  return {\n    major: +parts[0],\n    minor: +parts[1],\n    patch: +parts[2]\n  };\n}","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar transitionalDefaults = require('../defaults/transitional');\nvar AxiosError = require('../core/AxiosError');\nvar CanceledError = require('../cancel/CanceledError');\nvar parseProtocol = require('../helpers/parseProtocol');\nvar platform = require('../platform');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var withXSRFToken = config.withXSRFToken;\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || transitionalDefaults;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));\n      if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {\n        // Add xsrf header\n        var xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);\n        if (xsrfValue) {\n          requestHeaders[config.xsrfHeaderName] = xsrfValue;\n        }\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    // false, 0 (zero number), and '' (empty string) are valid JSON values\n    if (!requestData && requestData !== false && requestData !== 0 && requestData !== '') {\n      requestData = null;\n    }\n\n    var protocol = parseProtocol(fullPath);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\nvar formDataToJSON = require('./helpers/formDataToJSON');\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = require('./cancel/CanceledError');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\naxios.VERSION = require('./env/data').version;\naxios.toFormData = require('./helpers/toFormData');\n\n// Expose AxiosError class\naxios.AxiosError = require('../lib/core/AxiosError');\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\n// Expose isAxiosError\naxios.isAxiosError = require('./helpers/isAxiosError');\n\naxios.formToJSON = function(thing) {\n  return formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n};\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\nvar CanceledError = require('./CanceledError');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n\n  // eslint-disable-next-line func-names\n  this.promise.then(function(cancel) {\n    if (!token._listeners) return;\n\n    var i = token._listeners.length;\n\n    while (i-- > 0) {\n      token._listeners[i](cancel);\n    }\n    token._listeners = null;\n  });\n\n  // eslint-disable-next-line func-names\n  this.promise.then = function(onfulfilled) {\n    var _resolve;\n    // eslint-disable-next-line func-names\n    var promise = new Promise(function(resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message, config, request) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new CanceledError(message, config, request);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Subscribe to the cancel signal\n */\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n\n/**\n * Unsubscribe from the cancel signal\n */\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n  var index = this._listeners.indexOf(listener);\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nvar AxiosError = require('../core/AxiosError');\nvar utils = require('../utils');\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\nmodule.exports = CanceledError;\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\nvar buildFullPath = require('./buildFullPath');\nvar validator = require('../helpers/validator');\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n * @param {?Object} config\n */\nAxios.prototype.request = function request(configOrUrl, config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof configOrUrl === 'string') {\n    config = config || {};\n    config.url = configOrUrl;\n  } else {\n    config = configOrUrl || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  }\n\n  var paramsSerializer = config.paramsSerializer;\n\n  if (paramsSerializer !== undefined) {\n    validator.assertOptions(paramsSerializer, {\n      encode: validators.function,\n      serialize: validators.function\n    }, true);\n  }\n\n  utils.isFunction(paramsSerializer) && (config.paramsSerializer = {serialize: paramsSerializer});\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  var fullPath = buildFullPath(config.baseURL, config.url);\n  return buildURL(fullPath, config.params, config.paramsSerializer);\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method: method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url: url,\n        data: data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\n\nvar prototype = AxiosError.prototype;\nvar descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(function(code) {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = function(error, code, config, request, response, customProps) {\n  var axiosError = Object.create(prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\nmodule.exports = AxiosError;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Clear all interceptors from the stack\n */\nInterceptorManager.prototype.clear = function clear() {\n  if (this.handlers) {\n    this.handlers = [];\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\nvar CanceledError = require('../cancel/CanceledError');\nvar normalizeHeaderName = require('../helpers/normalizeHeaderName');\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    null,\n    config.transformRequest\n  );\n\n  normalizeHeaderName(config.headers, 'Accept');\n  normalizeHeaderName(config.headers, 'Content-Type');\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      response.status,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          reason.response.status,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isEmptyObject(source)) {\n      return utils.merge({}, target);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'withXSRFToken': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'beforeRedirect': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n};\n","'use strict';\n\nvar AxiosError = require('./AxiosError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar defaults = require('../defaults');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Number} status HTTP status code\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, status, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers, status);\n  });\n\n  return data;\n};\n","'use strict';\n\nvar utils = require('../utils');\nvar normalizeHeaderName = require('../helpers/normalizeHeaderName');\nvar AxiosError = require('../core/AxiosError');\nvar transitionalDefaults = require('./transitional');\nvar toFormData = require('../helpers/toFormData');\nvar toURLEncodedForm = require('../helpers/toURLEncodedForm');\nvar platform = require('../platform');\nvar formDataToJSON = require('../helpers/formDataToJSON');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('../adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('../adapters/http');\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    var contentType = headers && headers['Content-Type'] || '';\n    var hasJSONContentType = contentType.indexOf('application/json') > -1;\n    var isObjectPayload = utils.isObject(data);\n\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    var isFormData = utils.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n\n    var isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') !== -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        var _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var JSONRequested = this.responseType === 'json';\n\n    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      var silentJSONParsing = transitional && transitional.silentJSONParsing;\n      var strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nmodule.exports = {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n","// eslint-disable-next-line strict\nmodule.exports = require('form-data');\n","module.exports = {\n  \"version\": \"0.28.1\"\n};","'use strict';\n\nvar toFormData = require('./toFormData');\n\nfunction encode(str) {\n  var charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'\\(\\)~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nvar prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  var _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\nmodule.exports = AxiosURLSearchParams;\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n};\n","'use strict';\n\nvar utils = require('../utils');\nvar AxiosURLSearchParams = require('../helpers/AxiosURLSearchParams');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var hashmarkIndex = url.indexOf('#');\n\n  if (hashmarkIndex !== -1) {\n    url = url.slice(0, hashmarkIndex);\n  }\n\n  var _encode = options && options.encode || encode;\n\n  var serializeFn = options && options.serialize;\n\n  var serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ?\n      params.toString() :\n      new AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('../utils');\n\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(function(match) {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\nfunction arrayToObject(arr) {\n  var obj = {};\n  var keys = Object.keys(arr);\n  var i;\n  var len = keys.length;\n  var key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    var name = path[index++];\n    var isNumericKey = Number.isFinite(+name);\n    var isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils.hasOwnProperty(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    var result = buildPath(path, value, target[name], index);\n\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    var obj = {};\n\n    utils.forEachEntry(formData, function(name, value) {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\nmodule.exports = formDataToJSON;\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n      * Parse a URL to discover it's components\n      *\n      * @param {String} url The URL to be parsed\n      * @returns {Object}\n      */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n          // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n      * Determine if a URL shares the same origin as the current location\n      *\n      * @param {String} requestURL The URL to test\n      * @returns {boolean} True if URL shares the same origin, otherwise false\n      */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n    // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.slice(0, i)).toLowerCase();\n    val = utils.trim(line.slice(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nmodule.exports = function parseProtocol(url) {\n  var match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n};\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\nvar utils = require('../utils');\nvar AxiosError = require('../core/AxiosError');\nvar envFormData = require('../env/classes/FormData');\n\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\nfunction removeBrackets(key) {\n  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\n\nvar predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\nfunction isSpecCompliant(thing) {\n  return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator];\n}\n\n/**\n * Convert a data object to FormData\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n * @returns {Object}\n **/\n\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (envFormData || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n\n  var metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  var visitor = options.visitor || defaultVisitor;\n  var dots = options.dots;\n  var indexes = options.indexes;\n  var _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  var useBlob = _Blob && isSpecCompliant(formData);\n\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && utils.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    var arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils.isArray(value) && isFlatArray(value)) ||\n        (utils.isFileList(value) || utils.endsWith(key, '[]') && (arr = utils.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !utils.isUndefined(el) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  var stack = [];\n\n  var exposedHelpers = Object.assign(predicates, {\n    defaultVisitor: defaultVisitor,\n    convertValue: convertValue,\n    isVisitable: isVisitable\n  });\n\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils.forEach(value, function each(el, key) {\n      var result = !utils.isUndefined(el) && visitor.call(\n        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\nmodule.exports = toFormData;\n","'use strict';\n\nvar utils = require('../utils');\nvar toFormData = require('./toFormData');\nvar platform = require('../platform/');\n\nmodule.exports = function toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n};\n","'use strict';\n\nvar VERSION = require('../env/data').version;\nvar AxiosError = require('../core/AxiosError');\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};\n","'use strict';\n\nmodule.exports = FormData;\n","'use strict';\n\nvar AxiosURLSearchParams = require('../../../helpers/AxiosURLSearchParams');\n\nmodule.exports = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;\n","'use strict';\n\nmodule.exports = {\n  isBrowser: true,\n  classes: {\n    URLSearchParams: require('./classes/URLSearchParams'),\n    FormData: require('./classes/FormData'),\n    Blob: Blob\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n","'use strict';\n\nmodule.exports = require('./node/');\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n// eslint-disable-next-line func-names\nvar kindOf = (function(cache) {\n  // eslint-disable-next-line func-names\n  return function(thing) {\n    var str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n  };\n})(Object.create(null));\n\nfunction kindOfTest(type) {\n  type = type.toLowerCase();\n  return function isKindOf(thing) {\n    return kindOf(thing) === type;\n  };\n}\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nvar isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a empty Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a empty Object, otherwise false\n */\nfunction isEmptyObject(val) {\n  return val && Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nvar isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nvar isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nvar isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nvar isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} thing The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(thing) {\n  var pattern = '[object FormData]';\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) ||\n    toString.call(thing) === pattern ||\n    (isFunction(thing.toString) && thing.toString() === pattern)\n  );\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nvar isURLSearchParams = kindOfTest('URLSearchParams');\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  var product;\n  if (typeof navigator !== 'undefined' && (\n    (product = navigator.product) === 'ReactNative' ||\n    product === 'NativeScript' ||\n    product === 'NS')\n  ) {\n    return false;\n  }\n\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n */\n\nfunction inherits(constructor, superConstructor, props, descriptors) {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n * @returns {Object}\n */\n\nfunction toFlatObject(sourceObj, destObj, filter, propFilter) {\n  var props;\n  var i;\n  var prop;\n  var merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && Object.getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/*\n * determines whether a string ends with the characters of a specified string\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n * @returns {boolean}\n */\nfunction endsWith(str, searchString, position) {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  var lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n * @param {*} [thing]\n * @returns {?Array}\n */\nfunction toArray(thing) {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  var i = thing.length;\n  if (!isNumber(i)) return null;\n  var arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n// eslint-disable-next-line func-names\nvar isTypedArray = (function(TypedArray) {\n  // eslint-disable-next-line func-names\n  return function(thing) {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));\n\nfunction forEachEntry(obj, fn) {\n  var generator = obj && obj[Symbol.iterator];\n\n  var iterator = generator.call(obj);\n\n  var result;\n\n  while ((result = iterator.next()) && !result.done) {\n    var pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\nfunction matchAll(regExp, str) {\n  var matches;\n  var arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\nvar isHTMLForm = kindOfTest('HTMLFormElement');\n\nvar hasOwnProperty = (function resolver(_hasOwnProperty) {\n  return function(obj, prop) {\n    return _hasOwnProperty.call(obj, prop);\n  };\n})(Object.prototype.hasOwnProperty);\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isEmptyObject: isEmptyObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM,\n  inherits: inherits,\n  toFlatObject: toFlatObject,\n  kindOf: kindOf,\n  kindOfTest: kindOfTest,\n  endsWith: endsWith,\n  toArray: toArray,\n  isTypedArray: isTypedArray,\n  isFileList: isFileList,\n  forEachEntry: forEachEntry,\n  matchAll: matchAll,\n  isHTMLForm: isHTMLForm,\n  hasOwnProperty: hasOwnProperty\n};\n","// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nexport function convertChangesToDMP(changes) {\n  let ret = [],\n      change,\n      operation;\n  for (let i = 0; i < changes.length; i++) {\n    change = changes[i];\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n  return ret;\n}\n","export function convertChangesToXML(changes) {\n  let ret = [];\n  for (let i = 0; i < changes.length; i++) {\n    let change = changes[i];\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  let n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n\n  return n;\n}\n","import Diff from './base';\n\nexport const arrayDiff = new Diff();\narrayDiff.tokenize = function(value) {\n  return value.slice();\n};\narrayDiff.join = arrayDiff.removeEmpty = function(value) {\n  return value;\n};\n\nexport function diffArrays(oldArr, newArr, callback) { return arrayDiff.diff(oldArr, newArr, callback); }\n","export default function Diff() {}\n\nDiff.prototype = {\n  diff(oldString, newString, options = {}) {\n    let callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n\n    let self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function() { callback(undefined, value); }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n\n    let newLen = newString.length, oldLen = oldString.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    if(options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n    const maxExecutionTime = options.timeout ?? Infinity;\n    const abortAfterTimestamp = Date.now() + maxExecutionTime;\n\n    let bestPath = [{ oldPos: -1, lastComponent: undefined }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let newPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done([{value: this.join(newString), count: newString.length}]);\n    }\n\n    // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (\n        let diagonalPath = Math.max(minDiagonalToConsider, -editLength);\n        diagonalPath <= Math.min(maxDiagonalToConsider, editLength);\n        diagonalPath += 2\n      ) {\n        let basePath;\n        let removePath = bestPath[diagonalPath - 1],\n            addPath = bestPath[diagonalPath + 1];\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        let canAdd = false;\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          const addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n\n        let canRemove = removePath && removePath.oldPos + 1 < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        // TODO: Remove the `+ 1` here to make behavior match Myers algorithm\n        //       and prefer to order removals before insertions.\n        if (!canRemove || (canAdd && removePath.oldPos + 1 < addPath.oldPos)) {\n          basePath = self.addToPath(addPath, true, undefined, 0);\n        } else {\n          basePath = self.addToPath(removePath, undefined, true, 1);\n        }\n\n        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n        } else {\n          bestPath[diagonalPath] = basePath;\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n    if (callback) {\n      (function exec() {\n        setTimeout(function() {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      }());\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        let ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  addToPath(path, added, removed, oldPosInc) {\n    let last = path.lastComponent;\n    if (last && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {count: 1, added: added, removed: removed, previousComponent: last }\n      };\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n        oldLen = oldString.length,\n        oldPos = basePath.oldPos,\n        newPos = oldPos - diagonalPath,\n\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.lastComponent = {count: commonCount, previousComponent: basePath.lastComponent};\n    }\n\n    basePath.oldPos = oldPos;\n    return newPos;\n  },\n\n  equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right\n        || (this.options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n    }\n  },\n  removeEmpty(array) {\n    let ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput(value) {\n    return value;\n  },\n  tokenize(value) {\n    return value.split('');\n  },\n  join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n  // First we convert our linked list of components in reverse order to an\n  // array in the right order:\n  const components = [];\n  let nextComponent;\n  while (lastComponent) {\n    components.push(lastComponent);\n    nextComponent = lastComponent.previousComponent;\n    delete lastComponent.previousComponent;\n    lastComponent = nextComponent;\n  }\n  components.reverse();\n\n  let componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function(value, i) {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let finalComponent = components[componentLen - 1];\n  if (componentLen > 1\n      && typeof finalComponent.value === 'string'\n      && (finalComponent.added || finalComponent.removed)\n      && diff.equals('', finalComponent.value)) {\n    components[componentLen - 2].value += finalComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n","import Diff from './base';\n\nexport const characterDiff = new Diff();\nexport function diffChars(oldStr, newStr, options) { return characterDiff.diff(oldStr, newStr, options); }\n","import Diff from './base';\n\nexport const cssDiff = new Diff();\ncssDiff.tokenize = function(value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nexport function diffCss(oldStr, newStr, callback) { return cssDiff.diff(oldStr, newStr, callback); }\n","import Diff from './base';\nimport {lineDiff} from './line';\n\nconst objectPrototypeToString = Object.prototype.toString;\n\n\nexport const jsonDiff = new Diff();\n// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\n\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function(value) {\n  const {undefinedReplacement, stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v} = this.options;\n\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\njsonDiff.equals = function(left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nexport function diffJson(oldObj, newObj, options) { return jsonDiff.diff(oldObj, newObj, options); }\n\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nexport function canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  let i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  let canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    let sortedKeys = [],\n        key;\n    for (key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(key)) {\n        sortedKeys.push(key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      key = sortedKeys[i];\n      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}\n","import Diff from './base';\nimport {generateOptions} from '../util/params';\n\nexport const lineDiff = new Diff();\nlineDiff.tokenize = function(value) {\n  if(this.options.stripTrailingCr) {\n    // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n    value = value.replace(/\\r\\n/g, '\\n');\n  }\n\n  let retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n  // Ignore the final empty token that occurs if the string ends with a new line\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  }\n\n  // Merge the content and line separators into single tokens\n  for (let i = 0; i < linesAndNewlines.length; i++) {\n    let line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nexport function diffLines(oldStr, newStr, callback) { return lineDiff.diff(oldStr, newStr, callback); }\nexport function diffTrimmedLines(oldStr, newStr, callback) {\n  let options = generateOptions(callback, {ignoreWhitespace: true});\n  return lineDiff.diff(oldStr, newStr, options);\n}\n","import Diff from './base';\n\n\nexport const sentenceDiff = new Diff();\nsentenceDiff.tokenize = function(value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nexport function diffSentences(oldStr, newStr, callback) { return sentenceDiff.diff(oldStr, newStr, callback); }\n","import Diff from './base';\nimport {generateOptions} from '../util/params';\n\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 008000FF\n//  - U+00D7   Multiplication sign\n//  - U+00F7   Division sign\n// Latin Extended-A, 0100017F\n// Latin Extended-B, 0180024F\n// IPA Extensions, 025002AF\n// Spacing Modifier Letters, 02B002FF\n//  - U+02C7   &#711;  Caron\n//  - U+02D8   &#728;  Breve\n//  - U+02D9   &#729;  Dot Above\n//  - U+02DA   &#730;  Ring Above\n//  - U+02DB   &#731;  Ogonek\n//  - U+02DC   &#732;  Small Tilde\n//  - U+02DD   &#733;  Double Acute Accent\n// Latin Extended Additional, 1E001EFF\nconst extendedWordChars = /^[a-zA-Z\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}]+$/u;\n\nconst reWhitespace = /\\S/;\n\nexport const wordDiff = new Diff();\nwordDiff.equals = function(left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n  return left === right || (this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\n};\nwordDiff.tokenize = function(value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  let tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/);\n\n  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n  for (let i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2]\n          && extendedWordChars.test(tokens[i])\n          && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nexport function diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {ignoreWhitespace: true});\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n","/* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIs:\n * Diff.diffChars: Character by character diff\n * Diff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * Diff.diffLines: Line based diff\n *\n * Diff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\nimport Diff from './diff/base';\nimport {diffChars} from './diff/character';\nimport {diffWords, diffWordsWithSpace} from './diff/word';\nimport {diffLines, diffTrimmedLines} from './diff/line';\nimport {diffSentences} from './diff/sentence';\n\nimport {diffCss} from './diff/css';\nimport {diffJson, canonicalize} from './diff/json';\n\nimport {diffArrays} from './diff/array';\n\nimport {applyPatch, applyPatches} from './patch/apply';\nimport {parsePatch} from './patch/parse';\nimport {merge} from './patch/merge';\nimport {reversePatch} from './patch/reverse';\nimport {structuredPatch, createTwoFilesPatch, createPatch, formatPatch} from './patch/create';\n\nimport {convertChangesToDMP} from './convert/dmp';\nimport {convertChangesToXML} from './convert/xml';\n\nexport {\n  Diff,\n\n  diffChars,\n  diffWords,\n  diffWordsWithSpace,\n  diffLines,\n  diffTrimmedLines,\n  diffSentences,\n\n  diffCss,\n  diffJson,\n\n  diffArrays,\n\n  structuredPatch,\n  createTwoFilesPatch,\n  createPatch,\n  formatPatch,\n  applyPatch,\n  applyPatches,\n  parsePatch,\n  merge,\n  reversePatch,\n  convertChangesToDMP,\n  convertChangesToXML,\n  canonicalize\n};\n","import {parsePatch} from './parse';\nimport distanceIterator from '../util/distance-iterator';\n\nexport function applyPatch(source, uniDiff, options = {}) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  }\n\n  // Apply the diff to the input\n  let lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n\n      compareLine = options.compareLine || ((lineNumber, line, operation, patchContent) => line === patchContent),\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n\n      removeEOFNL,\n      addEOFNL;\n\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n  function hunkFits(hunk, toPos) {\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line);\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n\n    return true;\n  }\n\n  // Search best fit offsets for each hunk based on the previous ones\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n\n    let iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  }\n\n  // Apply patch hunks\n  let diffOffset = 0;\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        toPos = hunk.oldStart + hunk.offset + diffOffset - 1;\n    diffOffset += hunk.newLines - hunk.oldLines;\n\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line),\n          delimiter = hunk.linedelimiters && hunk.linedelimiters[j] || '\\n';\n\n      if (operation === ' ') {\n        toPos++;\n      } else if (operation === '-') {\n        lines.splice(toPos, 1);\n        delimiters.splice(toPos, 1);\n      /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(toPos, 0, content);\n        delimiters.splice(toPos, 0, delimiter);\n        toPos++;\n      } else if (operation === '\\\\') {\n        let previousOperation = hunk.lines[j - 1] ? hunk.lines[j - 1][0] : null;\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  }\n\n  // Handle EOFNL insertion/removal\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (let _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nexport function applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  let currentIndex = 0;\n  function processIndex() {\n    let index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function(err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      let updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function(err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\n","import {diffLines} from '../diff/line';\n\nexport function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  const diff = diffLines(oldStr, newStr, options);\n  if(!diff) {\n    return;\n  }\n\n  diff.push({value: '', lines: []}); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function(entry) { return ' ' + entry; });\n  }\n\n  let hunks = [];\n  let oldRangeStart = 0, newRangeStart = 0, curRange = [],\n      oldLine = 1, newLine = 1;\n  for (let i = 0; i < diff.length; i++) {\n    const current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        const prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      }\n\n      // Output our changes\n      curRange.push(... lines.map(function(entry) {\n        return (current.added ? '+' : '-') + entry;\n      }));\n\n      // Track the updated file position\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          // Overlapping\n          curRange.push(... contextLines(lines));\n        } else {\n          // end the range and output\n          let contextSize = Math.min(lines.length, options.context);\n          curRange.push(... contextLines(lines.slice(0, contextSize)));\n\n          let hunk = {\n            oldStart: oldRangeStart,\n            oldLines: (oldLine - oldRangeStart + contextSize),\n            newStart: newRangeStart,\n            newLines: (newLine - newRangeStart + contextSize),\n            lines: curRange\n          };\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            let oldEOFNewline = ((/\\n$/).test(oldStr));\n            let newEOFNewline = ((/\\n$/).test(newStr));\n            let noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n            if ((!oldEOFNewline && !noNlBeforeAdds) || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n          hunks.push(hunk);\n\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  }\n\n  return {\n    oldFileName: oldFileName, newFileName: newFileName,\n    oldHeader: oldHeader, newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nexport function formatPatch(diff) {\n  if (Array.isArray(diff)) {\n    return diff.map(formatPatch).join('\\n');\n  }\n\n  const ret = [];\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (let i = 0; i < diff.hunks.length; i++) {\n    const hunk = diff.hunks[i];\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n    ret.push(\n      '@@ -' + hunk.oldStart + ',' + hunk.oldLines\n      + ' +' + hunk.newStart + ',' + hunk.newLines\n      + ' @@'\n    );\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nexport function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\n\nexport function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n","import {structuredPatch} from './create';\nimport {parsePatch} from './parse';\n\nimport {arrayEqual, arrayStartsWith} from '../util/array';\n\nexport function calcLineCount(hunk) {\n  const {oldLines, newLines} = calcOldNewLineCount(hunk.lines);\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nexport function merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n\n  let ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n\n  let mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    let mineCurrent = mine.hunks[mineIndex] || {oldStart: Infinity},\n        theirsCurrent = theirs.hunks[theirsIndex] || {oldStart: Infinity};\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      let mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if ((/^@@/m).test(param) || ((/^Index:/m).test(param))) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {mine, theirs};\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart\n    && (test.oldStart + test.oldLines) < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  let mine = {offset: mineOffset, lines: mineLines, index: 0},\n      their = {offset: theirOffset, lines: theirLines, index: 0};\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    let mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+')\n        && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      // Mine inserted\n      hunk.lines.push(... collectChange(mine));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      // Theirs inserted\n      hunk.lines.push(... collectChange(their));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges)\n        && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      hunk.lines.push(... myChanges);\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges)\n        && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      hunk.lines.push(... theirChanges);\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    hunk.lines.push(... myChanges);\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    hunk.lines.push(... theirChanges.merged);\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  let ret = [],\n      operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    let line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  let changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n  while (matchIndex < matchChanges.length\n        && state.index < state.lines.length) {\n    let change = state.lines[state.index],\n        match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+'\n      && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged,\n    changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function(prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (let i = 0; i < delta; i++) {\n    let changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  let oldLines = 0;\n  let newLines = 0;\n\n  lines.forEach(function(line) {\n    if (typeof line !== 'string') {\n      let myCount = calcOldNewLineCount(line.mine);\n      let theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n\n  return {oldLines, newLines};\n}\n","export function parsePatch(uniDiff, options = {}) {\n  let diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    let index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if ((/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/).test(line)) {\n        break;\n      }\n\n      // Diff index\n      let header = (/^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/).exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      if ((/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/).test(line)) {\n        break;\n      } else if ((/^@@/).test(line)) {\n        index.hunks.push(parseHunk());\n      } else if (line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    const fileHeader = (/^(---|\\+\\+\\+)\\s+(.*)$/).exec(diffstr[i]);\n    if (fileHeader) {\n      let keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      const data = fileHeader[2].split('\\t', 2);\n      let fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if ((/^\".*\"$/).test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    let chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n    let hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    };\n\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    let addCount = 0,\n        removeCount = 0;\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0\n            && (i + 2 < diffstr.length)\n            && diffstr[i + 1].indexOf('+++ ') === 0\n            && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n      }\n      let operation = (diffstr[i].length == 0 && i != (diffstr.length - 1)) ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform optional sanity checking\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n","export function reversePatch(structuredPatch) {\n  if (Array.isArray(structuredPatch)) {\n    return structuredPatch.map(reversePatch).reverse();\n  }\n\n  return {\n    ...structuredPatch,\n    oldFileName: structuredPatch.newFileName,\n    oldHeader: structuredPatch.newHeader,\n    newFileName: structuredPatch.oldFileName,\n    newHeader: structuredPatch.oldHeader,\n    hunks: structuredPatch.hunks.map(hunk => {\n      return {\n        oldLines: hunk.newLines,\n        oldStart: hunk.newStart,\n        newLines: hunk.oldLines,\n        newStart: hunk.oldStart,\n        linedelimiters: hunk.linedelimiters,\n        lines: hunk.lines.map(l => {\n          if (l.startsWith('-')) { return `+${l.slice(1)}`; }\n          if (l.startsWith('+')) { return `-${l.slice(1)}`; }\n          return l;\n        })\n      };\n    })\n  };\n}\n","export function arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\n\nexport function arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nexport default function(start, minLine, maxLine) {\n  let wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      }\n\n      // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      }\n\n      // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    }\n\n    // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n  };\n}\n","export function generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (let name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n  return defaults;\n}\n"],"names":["Action","PopStateEventType","createBrowserHistory","options","getUrlBasedHistory","window","globalHistory","pathname","search","hash","location","createLocation","state","usr","key","to","createPath","invariant","value","message","Error","warning","cond","console","warn","e","getHistoryState","index","idx","current","_extends","parsePath","Math","random","toString","substr","_ref","charAt","path","parsedPath","hashIndex","indexOf","searchIndex","getLocation","createHref","validateLocation","document","defaultView","v5Compat","history","action","Pop","listener","getIndex","handlePop","nextIndex","delta","createURL","base","origin","href","replace","URL","replaceState","listen","fn","addEventListener","removeEventListener","encodeLocation","url","push","Push","historyState","pushState","error","DOMException","name","assign","Replace","go","n","ResultType","immutableRouteKeys","Set","convertRoutesToDataRoutes","routes","mapRouteProperties","parentPath","manifest","map","route","treePath","id","join","children","isIndexRoute","indexRoute","pathOrLayoutRoute","undefined","matchRoutes","locationArg","basename","stripBasename","branches","flattenRoutes","sort","a","b","score","siblings","length","slice","every","i","compareIndexes","routesMeta","meta","childrenIndex","rankRouteBranches","matches","decoded","decodePath","matchRouteBranch","parentsMeta","flattenRoute","relativePath","caseSensitive","startsWith","joinPaths","concat","computeScore","forEach","_route$path","includes","exploded","explodeOptionalSegments","segments","split","first","rest","isOptional","endsWith","required","restExploded","result","subpath","paramRe","dynamicSegmentValue","indexRouteValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","s","initialScore","some","filter","reduce","segment","test","branch","matchedParams","matchedPathname","end","remainingPathname","match","matchPath","Object","params","pathnameBase","normalizePathname","pattern","matcher","compiledParams","regexpSource","_","paramName","RegExp","compilePath","captureGroups","memo","splatValue","v","decodeURIComponent","toLowerCase","startIndex","nextChar","getInvalidPathError","char","field","dest","JSON","stringify","getPathContributingMatches","getResolveToMatches","v7_relativeSplatPath","pathMatches","resolveTo","toArg","routePathnames","locationPathname","isPathRelative","from","isEmptyPath","toPathname","routePathnameIndex","toSegments","shift","fromPathname","pop","resolvePathname","normalizeSearch","normalizeHash","resolvePath","hasExplicitTrailingSlash","hasCurrentTrailingSlash","paths","AbortedDeferredError","ErrorResponseImpl","constructor","status","statusText","data","internal","this","isRouteErrorResponse","validMutationMethodsArr","validMutationMethods","validRequestMethodsArr","validRequestMethods","redirectStatusCodes","redirectPreserveMethodStatusCodes","IDLE_NAVIGATION","formMethod","formAction","formEncType","formData","json","text","IDLE_FETCHER","IDLE_BLOCKER","proceed","reset","ABSOLUTE_URL_REGEX","defaultMapRouteProperties","hasErrorBoundary","Boolean","TRANSITIONS_STORAGE_KEY","createRouter","init","routerWindow","isBrowser","createElement","isServer","detectErrorBoundary","inFlightDataRoutes","initialized","dataRoutes","dataStrategyImpl","unstable_dataStrategy","defaultDataStrategy","future","v7_fetcherPersist","v7_normalizeFormMethod","v7_partialHydration","v7_prependBasename","unstable_skipActionErrorRevalidation","unlistenHistory","subscribers","savedScrollPositions","getScrollRestorationKey","getScrollPosition","initialScrollRestored","hydrationData","initialMatches","initialErrors","getInternalRouterError","getShortCircuitMatches","router","hasLazyRoutes","m","lazy","hasLoaders","loader","loaderData","errors","isRouteInitialized","hydrate","findIndex","pendingNavigationController","historyAction","navigation","restoreScrollPosition","preventScrollReset","revalidation","actionData","fetchers","Map","blockers","pendingAction","pendingPreventScrollReset","pendingViewTransitionEnabled","appliedViewTransitions","removePageHideEventListener","isUninterruptedRevalidation","isRevalidationRequired","cancelledDeferredRoutes","cancelledFetcherLoads","fetchControllers","incrementingLoadId","pendingNavigationLoadId","fetchReloadIds","fetchRedirectIds","fetchLoadMatches","activeFetchers","deletedFetchers","activeDeferreds","blockerFunctions","ignoreNextHistoryUpdate","updateState","newState","opts","completedFetchers","deletedFetchersKeys","fetcher","has","subscriber","unstable_viewTransitionOpts","viewTransitionOpts","unstable_flushSync","flushSync","delete","deleteFetcher","completeNavigation","_temp","_location$state","_location$state2","isActionReload","isMutationMethod","_isRedirect","keys","mergeLoaderData","size","k","set","priorPaths","get","currentLocation","nextLocation","toPaths","add","getSavedScrollPosition","async","startNavigation","abort","startUninterruptedRevalidation","getScrollKey","saveScrollPosition","enableViewTransition","routesToUse","loadingNavigation","overrideNavigation","notFoundMatches","cancelActiveDeferreds","isHashChangeOnly","submission","AbortController","pendingActionResult","request","createClientSideRequest","signal","pendingError","findNearestBoundary","type","actionResult","interruptActiveLoads","getSubmittingNavigation","actionMatch","getTargetMatch","callDataStrategy","aborted","shortCircuited","method","routeId","isRedirectResult","normalizeRedirectLocation","response","headers","startRedirectNavigation","isDeferredResult","isErrorResult","boundaryMatch","handleAction","getLoadingNavigation","fetcherSubmission","initialHydration","activeSubmission","getSubmissionFromNavigation","matchesToLoad","revalidatingFetchers","getMatchesToLoad","updatedFetchers","markFetchRedirectsDone","getActionDataForCommit","rf","revalidatingFetcher","getLoadingFetcher","abortFetcher","controller","abortPendingFetchRevalidations","f","loaderResults","fetcherResults","callLoadersAndMaybeResolveData","redirect","findRedirect","fetcherKey","processLoaderData","deferredData","subscribe","done","entries","_ref2","_ref3","didAbortFetchLoads","abortStaleFetchLoads","shouldUpdateFetchers","handleLoaders","_temp2","redirectLocation","isDocumentReload","redirectHistoryAction","results","callDataStrategyImpl","Promise","all","isRedirectHandlerResult","normalizeRelativeRoutingRedirectResponse","convertHandlerResultToDataResult","currentMatches","fetchersToLoad","then","r","resolve","resolveDeferredResults","updateFetcherState","setFetcherError","getFetcher","markFetchersDone","doneFetcher","getDoneFetcher","doneKeys","landedId","yeetedKeys","deleteBlocker","updateBlocker","newBlocker","blocker","shouldBlockNavigation","_ref4","Array","blockerKey","blockerFunction","predicate","cancelledRouteIds","dfd","cancel","handle","convertRouteMatchToUiMatch","y","initialize","_window","transitions","sessionPositions","sessionStorage","getItem","parse","isArray","restoreAppliedTransitions","_saveAppliedTransitions","setItem","persistAppliedTransitions","enableScrollRestoration","positions","getPosition","getKey","navigate","normalizedPath","normalizeTo","fromRouteId","relative","normalizeNavigateOptions","userReplace","unstable_viewTransition","fetch","requestMatches","existingFetcher","getSubmittingFetcher","abortController","fetchRequest","originatingLoadId","actionResults","revalidationRequest","loadId","loadFetcher","staleKey","handleFetcherAction","resolveDeferredData","handleFetcherLoader","revalidate","count","dispose","clear","getBlocker","_internalFetchControllers","_internalActiveDeferreds","_internalSetRoutes","newRoutes","Symbol","prependBasename","contextualMatches","activeRouteMatch","hasNakedIndexQuery","normalizeFormMethod","isFetcher","body","isSubmissionNavigation","isValidMethod","searchParams","getInvalidBodyError","rawFormMethod","toUpperCase","stripHashFromPath","FormData","URLSearchParams","acc","_ref5","String","convertFormDataToSearchParams","convertSearchParamsToFormData","append","getLoaderMatchesUntilBoundary","boundaryId","boundaryMatches","isInitialLoad","skipActionErrorRevalidation","currentUrl","nextUrl","actionStatus","statusCode","shouldSkipRevalidation","navigationMatches","currentLoaderData","currentMatch","isNew","isMissingData","isNewLoader","currentRouteMatch","nextRouteMatch","shouldRevalidateLoader","currentParams","nextParams","unstable_actionStatus","defaultShouldRevalidate","isNewRouteInstance","fetcherMatches","fetcherMatch","shouldRevalidate","currentPath","loaderMatch","arg","routeChoice","loadLazyRouteModule","lazyRoute","routeToUpdate","routeUpdates","lazyRouteProperty","isPropertyStaticallyDefined","requestContext","routeIdsToLoad","loadedMatches","shouldLoad","handlerOverride","staticContext","onReject","runHandler","handler","reject","abortPromise","handlerPromise","actualHandler","ctx","context","race","handlerError","catch","callLoaderOrAction","handlerResult","isResponse","contentType","deferred","resolveData","isDeferredData","_result$init","_result$init2","Headers","trimmedMatches","normalizedLocation","protocol","isSameBasename","Request","processRouteLoaderData","skipLoaderErrorBubbling","foundError","loaderHeaders","newLoaderData","mergedLoaderData","hasOwnProperty","reverse","find","_temp5","errorMessage","signals","isRevalidatingLoader","unwrap","unwrappedData","getAll","matchersByWindow","WeakMap","getMatcher","query","targetWindow","matchers","mql","matchMedia","refCount","media","useMediaQuery","setMatches","useState","useEffect","handleChange","addListener","removeListener","breakpointValues","names","and","next","getMaxQuery","breakpoint","min","getNext","breakpointOrMap","direction","breakpointMap","useMemo","getMinQuery","createBreakpointHook","xs","sm","md","lg","xl","xxl","useCallbackRef","ref","useRef","useEventCallback","useCommittedRef","useCallback","args","useEventListener","eventTarget","event","capture","target","useForceUpdate","dispatch","useReducer","isReactNative","global","navigator","product","useLayoutEffect","toFnRef","refA","refB","mergeRefs","useMounted","mounted","isMounted","usePrevious","MAX_DELAY_MS","setChainedTimeout","handleRef","timeoutAtMs","delayMs","Date","now","setTimeout","useTimeout","useWillUnmount","clearTimeout","onUnmount","valueRef","useUpdatedRef","_excluded","Anchor","React","onKeyDown","props","source","excluded","sourceKeys","_objectWithoutPropertiesLoose","buttonProps","useButtonProps","tagName","handleKeyDown","trim","role","_jsx","displayName","disabled","rel","onClick","tabIndex","handleClick","isTrivialHref","preventDefault","stopPropagation","Button","as","asProp","Component","ATTRIBUTE_PREFIX","PROPERTY_PREFIX","dataAttr","property","dataProp","useRefWithUpdate","forceUpdate","attachRef","element","Dropdown","defaultShow","show","rawShow","onSelect","onToggle","rawOnToggle","itemSelector","focusFirstItemOnShow","placement","useWindow","useUncontrolledProp","menuRef","setMenu","menuElement","toggleRef","setToggle","toggleElement","lastShow","lastSourceEvent","focusInDropdown","onSelectCtx","useContext","SelectableContext","toggle","nextShow","originalEvent","handleSelect","isPropagationStopped","contains","ownerDocument","activeElement","focusToggle","focus","maybeFocusFirst","focusType","isRoleMenu","qsa","getNextFocusedChild","offset","items","max","_menuRef$current","_toggleRef$current","fromMenu","fromToggle","_menuRef$current2","once","Provider","DropdownContext","Menu","DropdownMenu","Toggle","DropdownToggle","Item","DropdownItem","useDropdownItem","active","navContext","NavContext","activeKey","eventKey","makeEventKey","isActive","dropdownItemProps","noop","useDropdownMenu","arrowElement","attachArrowRef","hasShownRef","flip","rootCloseEvent","fixed","placementOverride","popperConfig","enableEventListeners","usePopper","shouldUsePopper","popper","mergeOptionsWithPopperConfig","enabled","enableEvents","menuProps","attributes","style","styles","metadata","hasShown","arrowProps","arrow","useClickOutside","clickTrigger","usePopperProp","_Fragment","el","_el$getAttribute","getAttribute","useDropdownToggle","useSSRSafeId","useRTGTransitionProps","onEnter","onEntering","onEntered","onExit","onExiting","onExited","addEndListener","major","getReactVersion","childRef","nodeRef","mergedRef","useMergedRefs","normalize","callback","param","handleEnter","handleEntering","handleEntered","handleExit","handleExiting","handleExited","handleAddEndListener","innerProps","cloneElement","component","transitionProps","ImperativeTransition","in","inProp","transition","exited","setExited","onTransition","isInitialRef","handleTransition","useIsomorphicEffect","stale","initial","isStale","useTransition","onFinish","combinedRef","renderTransition","runTransition","RTGTransition","NoopTransition","manager","useModalManager","provided","modalManager","ModalManager","getManager","modal","dialog","backdrop","remove","isTopModal","setDialogRef","setBackdropRef","Modal","forwardRef","className","keyboard","onBackdropClick","onEscapeKeyDown","backdropTransition","runBackdropTransition","autoFocus","enforceFocus","restoreFocus","restoreFocusOptions","renderDialog","renderBackdrop","providedManager","container","containerRef","onShow","onHide","ownerWindow","useWaitForDOMRef","prevShow","lastFocusRef","useImperativeHandle","canUseDOM","handleShow","removeKeydownListenerRef","handleDocumentKeyDown","removeFocusListenerRef","handleEnforceFocus","_modal$dialog$ownerDo","_modal$dialog","currentActiveElement","handleHide","_lastFocusRef$current","handleBackdropClick","currentTarget","isEscKey","defaultPrevented","dialogProps","unmountOnExit","mountOnEnter","appear","handleHidden","backdropElement","ReactDOM","_jsxs","Manager","OPEN_DATA_ATTRIBUTE","handleContainerOverflow","isRTL","modals","getScrollbarWidth","abs","innerWidth","documentElement","clientWidth","getBodyScrollbarWidth","getElement","setModalAttributes","_modal","removeModalAttributes","setContainerStyle","containerState","overflow","paddingProp","scrollBarWidth","parseInt","css","setAttribute","removeContainerStyle","removeAttribute","modalIdx","splice","EVENT_KEY_ATTR","Nav","needsRefocusRef","parentOnSelect","tabContext","TabContext","getControlledId","getControllerId","listNode","getNextActiveTab","currentListNode","activeChild","querySelector","nextActiveChild","dataset","NavItem","useNavItem","contextControllerId","contextControlledId","hasEnteredRef","child","onRootClose","onClose","handleKeyUp","doc","getRefTarget","currentEvent","removeKeyupListener","Overlay","outerRef","containerPadding","Transition","rootElement","mountOverlay","useRootClose","rootClose","rootCloseDisabled","_excluded2","_excluded3","useTabPanel","TabPanel","tabPanelProps","hidden","Tabs","userId","generateChildId","generateCustomChildId","propsOnSelect","propsActiveKey","defaultActiveKey","Panel","toModifierArray","_modifiers$eventListe","_modifiers$preventOve","_modifiers$preventOve2","_modifiers$offset","_modifiers$arrow","modifiers","toModifierMap","strategy","eventListeners","preventOverflow","padding","InitialTriggerEvents","click","mouseup","pointerup","onClickOutside","preventMouseClickOutsideRef","waitingForTrigger","handleMouseCapture","metaKey","altKey","ctrlKey","shiftKey","button","isLeftClickEvent","handleInitialMouse","handleMouse","_ownerWindow$event","_ownerWindow$parent","parent","removeInitialTriggerListener","removeMouseCaptureListener","removeMouseListener","mobileSafariHackListeners","call","nextState","createPopper","popperGenerator","defaultModifiers","hide","popperOffsets","computeStyles","disabledApplyStylesModifier","phase","ariaDescribedByModifier","effect","reference","elements","ids","_popper$getAttribute","EMPTY_MODIFIERS","referenceElement","popperElement","config","prevModifiers","popperInstanceRef","update","_popperInstanceRef$cu","_popperInstanceRef$cu2","popperState","setState","useSafeState","updateModifier","requires","nextModifiers","dequal","setOptions","destroy","resolveContainerRef","getBoundingClientRect","onResolved","resolvedRef","setRef","earlyRef","nextRef","Context","createContext","code","keyCode","parts","minor","patch","module","exports","utils","require","settle","cookies","buildURL","buildFullPath","parseHeaders","isURLSameOrigin","transitionalDefaults","AxiosError","CanceledError","parseProtocol","platform","onCanceled","requestData","requestHeaders","responseType","withXSRFToken","cancelToken","unsubscribe","isFormData","isStandardBrowserEnv","XMLHttpRequest","auth","username","password","unescape","encodeURIComponent","Authorization","btoa","fullPath","baseURL","onloadend","responseHeaders","getAllResponseHeaders","responseText","err","open","paramsSerializer","timeout","onreadystatechange","readyState","responseURL","onabort","ECONNABORTED","onerror","ERR_NETWORK","ontimeout","timeoutErrorMessage","transitional","clarifyTimeoutError","ETIMEDOUT","isFunction","xsrfValue","xsrfHeaderName","xsrfCookieName","read","val","setRequestHeader","isUndefined","withCredentials","onDownloadProgress","onUploadProgress","upload","protocols","ERR_BAD_REQUEST","send","bind","Axios","mergeConfig","defaults","formDataToJSON","axios","createInstance","defaultConfig","instance","prototype","extend","create","instanceConfig","CancelToken","isCancel","VERSION","toFormData","Cancel","promises","spread","isAxiosError","formToJSON","thing","isHTMLForm","executor","TypeError","resolvePromise","promise","token","_listeners","onfulfilled","_resolve","reason","throwIfRequested","c","ERR_CANCELED","inherits","__CANCEL__","InterceptorManager","dispatchRequest","validator","validators","interceptors","configOrUrl","assertOptions","silentJSONParsing","boolean","forcedJSONParsing","encode","function","serialize","requestInterceptorChain","synchronousRequestInterceptors","interceptor","runWhen","synchronous","unshift","fulfilled","rejected","responseInterceptorChain","chain","apply","newConfig","onFulfilled","onRejected","getUri","generateHTTPMethod","isForm","captureStackTrace","stack","toJSON","description","number","fileName","lineNumber","columnNumber","descriptors","defineProperties","defineProperty","customProps","axiosError","toFlatObject","obj","cause","handlers","use","eject","h","isAbsoluteURL","combineURLs","requestedURL","transformData","normalizeHeaderName","throwIfCancellationRequested","transformRequest","merge","common","adapter","transformResponse","config1","config2","getMergedValue","isPlainObject","isEmptyObject","mergeDeepProperties","prop","valueFromConfig2","defaultToConfig2","mergeDirectKeys","mergeMap","configValue","validateStatus","ERR_BAD_RESPONSE","floor","fns","toURLEncodedForm","DEFAULT_CONTENT_TYPE","setContentTypeIfUnset","process","getDefaultAdapter","isFileList","hasJSONContentType","isObjectPayload","isObject","isArrayBuffer","isBuffer","isStream","isFile","isBlob","isArrayBufferView","buffer","isURLSearchParams","formSerializer","_FormData","env","rawValue","parser","encoder","isString","stringifySafely","JSONRequested","strictJSONParsing","maxContentLength","maxBodyLength","classes","Blob","str","charMap","AxiosURLSearchParams","_pairs","_encode","pair","thisArg","arguments","hashmarkIndex","serializedParams","serializeFn","relativeURL","write","expires","domain","secure","cookie","isNumber","toGMTString","buildPath","isNumericKey","Number","isFinite","isLast","arr","len","arrayToObject","forEachEntry","matchAll","parsePropPath","payload","originURL","msie","userAgent","urlParsingNode","resolveURL","host","hostname","port","requestURL","parsed","normalizedName","ignoreDuplicateOf","line","exec","envFormData","isVisitable","removeBrackets","renderKey","dots","predicates","metaTokens","indexes","option","visitor","defaultVisitor","useBlob","toStringTag","iterator","convertValue","isDate","toISOString","isTypedArray","Buffer","isFlatArray","toArray","exposedHelpers","build","helpers","isNode","deprecatedWarnings","version","formatMessage","opt","desc","ERR_DEPRECATED","schema","allowUnknown","ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","cache","kindOf","kindOfTest","getPrototypeOf","l","TypedArray","Uint8Array","_hasOwnProperty","ArrayBuffer","isView","pipe","assignValue","stripBOM","content","charCodeAt","superConstructor","sourceObj","destObj","propFilter","merged","getOwnPropertyNames","searchString","position","lastIndex","regExp","changes","change","operation","ret","added","removed","escapeHTML","oldArr","newArr","arrayDiff","diff","tokenize","removeEmpty","Diff","buildValues","lastComponent","newString","oldString","useLongestToken","nextComponent","components","previousComponent","componentPos","componentLen","newPos","oldPos","tmp","oldValue","finalComponent","equals","_options$timeout","self","castInput","newLen","oldLen","editLength","maxEditLength","maxExecutionTime","Infinity","abortAfterTimestamp","bestPath","extractCommon","minDiagonalToConsider","maxDiagonalToConsider","execEditLength","diagonalPath","basePath","removePath","addPath","canAdd","addPathNewPos","canRemove","addToPath","oldPosInc","last","commonCount","left","right","comparator","ignoreCase","array","chars","oldStr","newStr","characterDiff","cssDiff","oldObj","newObj","jsonDiff","_base","_line","objectPrototypeToString","canonicalize","replacementStack","replacer","canonicalizedObj","_typeof","_key","sortedKeys","lineDiff","_this$options","undefinedReplacement","_this$options$stringi","stringifyReplacer","_params","generateOptions","ignoreWhitespace","stripTrailingCr","retLines","linesAndNewlines","newlineIsToken","sentenceDiff","wordDiff","extendedWordChars","reWhitespace","tokens","_character","_word","_sentence","_css","_json","_array","_apply","_parse","_merge","_reverse","_create","_dmp","_xml","uniDiff","parsePatch","currentIndex","processIndex","complete","loadFile","updatedContent","applyPatch","patched","_distanceIterator","removeEOFNL","addEOFNL","lines","delimiters","hunks","compareLine","patchContent","errorCount","fuzzFactor","minLine","hunkFits","hunk","toPos","j","maxLine","oldLines","localOffset","oldStart","diffOffset","_i","_hunk","_toPos","newLines","delimiter","linedelimiters","previousOperation","_k","oldHeader","newHeader","createTwoFilesPatch","structuredPatch","oldFileName","newFileName","diffLines","oldRangeStart","newRangeStart","curRange","oldLine","newLine","_loop","_curRange","prev","contextLines","_toConsumableArray","entry","_curRange2","_curRange3","contextSize","newStart","oldEOFNewline","newEOFNewline","noNlBeforeAdds","formatPatch","mine","theirs","loadPatch","fileNameChanged","selectField","mineIndex","theirsIndex","mineOffset","theirsOffset","mineCurrent","theirsCurrent","hunkBefore","cloneHunk","mergedHunk","mergeLines","calcLineCount","_calcOldNewLineCount","calcOldNewLineCount","conflict","check","mineLines","theirOffset","theirLines","their","insertLeading","theirCurrent","_hunk$lines","collectChange","_hunk$lines2","removal","mutualChange","insertTrailing","myChanges","theirChanges","allRemoves","_hunk$lines3","_hunk$lines4","arrayStartsWith","skipRemoveSuperset","arrayEqual","_hunk$lines5","swap","_hunk$lines6","matchChanges","matchIndex","contextChanges","conflicted","collectContext","insert","removeChanges","changeContent","myCount","theirCount","diffstr","list","parseIndex","header","parseFileHeader","parseHunk","strict","fileHeader","keyPrefix","chunkHeaderIndex","chunkHeader","addCount","removeCount","reversePatch","_objectSpread","start","wantForward","backwardExhausted","forwardExhausted"],"sourceRoot":""}